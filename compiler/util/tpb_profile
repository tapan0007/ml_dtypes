#!/usr/bin/env python3

# Copyright (C) 2018, Amazon.com. All Rights Reserved
#
# Kgraph visualization
#
# Sample commands:
'''
firefox /home/zejdaj/work/git/Kaena/qor/20180426/*

set d = 3-rn50-13_wave-zero ; cd $d ; $ku/tpb_profile --log working_dir/log-exec-sg00-*.txt --tpb sg00/*.tpb --verbose --show &

set d = 7-rn50_nne_fp16_wave-zero/ ; cd $d ; $ku/tpb_profile --log working_dir/log-exec-sg00-*.txt --tpb sg00/*.tpb --verbose --show --cycle_range  1.11565e6 1.142e6 &
'''

import argparse
import os, json, sys, re
import matplotlib.pyplot as plt

parser = argparse.ArgumentParser()
parser.add_argument('--log', help='Inkling debug log file (seenv SIM_DEBUG all; RunAll ...)', default=None)
parser.add_argument('--tpb', help='Tpb binary program files named ...-pe.tpb, ..-act.tpb', nargs='+', default=[])
parser.add_argument('--verbose', help='Verbose node content', action='store_true', default=False)
parser.add_argument('--show', help='Invoke interactive viewer', action='store_true', default=False)
parser.add_argument('--cycle_range', help='Display only activity within the cycle range, default 0 2e6', type=float, nargs=2, default=[0,2e6])
parser.add_argument('--geometry', help='Output size width height', type=int, nargs=2, default=[])
parser.add_argument('--long', help='Partitions long run into N cycle long blocks and saves png, default 0 (off)', type=float, default=0)
parser.add_argument('--event_statistics', help='Load profile data and compile event statistics, no visualization is done. Also overrides cycle_range to 0 1e9', action='store_true', default=False)

args = parser.parse_args()

if len(args.geometry) == 0:
  if args.long > 0:
    args.geometry = [12,4]
  else:
    args.geometry = [12,8]

class Instr:
  def __init__(self, instrType):
    self.instrType = instrType
    self.fields = {}
    self.textFields = ""
  def __str__(self):
    s = self.instrType
    #s += "\n" + "\n".join(["%s : %s" % (k, v) for k,v in self.fields.items()])
    s += "\n" + self.textFields
    return s
  def addField(self, field, value):
    self.fields[field] = value
  def getInstrType(self):
    return self.instrType
  def getSrcNumElem4D(self, src='mem', dim=4):
    num = 1
    for d in range(dim):
      num *= self.fields['src_%s_pattern.num_elem[%d]' % (src, d)]
    return num
  def getWaveCycles(self):
    cycles = 0;
    if self.instrType == 'MATMUL' or self.instrType == 'ACTIVATION':
      cycles = self.getSrcNumElem4D('mem',3)
    elif self.instrType == 'POOL':
      cycles = self.getSrcNumElem4D('mem', 4)
    elif self.instrType == 'TENSOR_TENSOR_OP':
      cycles = self.getSrcNumElem4D('psum_buf_mem', 3)
    return cycles
  def getOPC(self):
    opc = 0
    if self.instrType == 'MATMUL':
      opc = 2 * self.fields['num_active_rows'] * self.fields['num_active_cols']
    return opc
  def getOpCount(self):
    opCount = 0;
    if self.instrType == 'MATMUL':
      waveCycles = self.getWaveCycles()
      opCount = self.getOPC() * waveCycles
    return opCount
  # https://matplotlib.org/examples/color/named_colors.html
  i2c = {
     # PE
    "MATMUL"     : "red",
    "LDWEIGHTS"  : "rosybrown",
    "SET"        : "blue",
    "WAIT"       : "gray",
    "CLEAR"      : "aqua",
    # DMA
    "SIM_MEMCPY" : "green",
    "SIM_RDNPY:" : "darkgreen",
    "SIM_WRNPY:" : "olive",
    # ACT
    "ACTIVATION" : "orange",
    # POOL
    "POOL"       : "tan",
    "TENSOR_TENSOR_OP" : "khaki",
    }
  def getColor(self):
    return Instr.i2c.get(self.getInstrType(), "black")
  def hasEventModeNz(self, waitOrSet):
    mode = self.fields.get('inst_events.%s_event_mode' % waitOrSet, None)
    if mode != None:
      if mode > 0:
        return True
    return False
  def getEvents(self):
    ''' Event related ISA fields:
      167954   inst_events.wait_event_mode             [4, 4]: 0xXX
      167954   inst_events.wait_event_idx              [5, 5]: 0xXX
      167954   inst_events.set_event_mode              [6, 6]: 0xXX
      167954   inst_events.set_event_idx               [7, 7]: 0xXX
        2917   event_idx                               [4, 4]: 0xXX
        1241   wait_event_mode                         [4, 4]: 0xXX
        1241   event_idx                               [5, 5]: 0xXX
    '''
    waitEvents = []
    setEvents = []
    if self.hasEventModeNz('wait'):
      eventId = self.fields.get('inst_events.wait_event_idx', None)
      if eventId != None:
        waitEvents.append(eventId)
    if self.hasEventModeNz('set'):
      eventId = self.fields.get('inst_events.set_event_idx', None)
      if eventId != None:
        setEvents.append(eventId)
    eventId = self.fields.get('event_idx', None)
    if eventId != None:
      if self.getInstrType() == "WAIT":
        waitEvents.append(eventId)
      elif self.getInstrType() == "SET":
        setEvents.append(eventId)
      elif self.getInstrType() == "CLEAR":
        pass
      else:
        print("ERROR: instruction %s has unexpected event_idx" % self.getInstrType())
    return waitEvents, setEvents
    

class TpbProgram:
  def __init__(self, tpbFile):
    self.instructions = {}
    print("INFO: Loading " + tpbFile, flush=True)
    with os.popen('$INKLING_PATH/objdump/objdump ' + tpbFile) as fh:
      instr = None
      for line in fh:
        match = re.match('^(\S+) @ (\S+):', line)
        if match:
          pc, instrType = match.groups()
          instr = Instr(instrType)
          self.instructions[pc] = instr
        else:
          match = re.match('^  (\S+) .+: (0x\S+)', line)
          if match:
            instrField, value = match.groups()
            instr.addField(instrField, int(value, 0))
          instr.textFields += line
  
  def getInstrAt(self, pc):
    return self.instructions.get(pc, None)

class TongaProgram:
  def __init__(self, tongaFiles):
    self.tpbPrograms = {}
    for f in tongaFiles:
      match = re.search('(dma|pe|act|pool)\.tpb', f)
      if match:
        engine = match.groups()[0]
        self.tpbPrograms[engine] = TpbProgram(f)
  def getInstr(self, engine, pc):
    tpbProgram = self.tpbPrograms.get(engine, None)
    instr = None
    if tpbProgram != None:
      instr = tpbProgram.getInstrAt(pc)
    return instr

class InklingEvent(object):
  def __init__(self, cycle, engine, pc, opcode, mode, event):
    self.cycle = cycle
    self.engine = engine
    self.pc = pc
    self.mode = mode
    self.event = event
  def __str__(self):
    s = "Cycle=%d" % self.cycle
    s += "  Engine=%s" % self.engine
    s += "  PC=%s" % self.pc
    s += "  mode=%s" %self.mode
    s += "  event=%s" % self.event
    return s

class InklingProfile(object):
  def __init__(self, logFile, tongaProgram, verbose, cycleRange, show, geometry):
    self.logFile = logFile
    self.tongaProgram = tongaProgram
    self.verbose = verbose
    self.show = show
    self.geometry = geometry
    self.cycleRange = cycleRange
    self.ops = []
    self.events = []
    self.numCycles = 1
    self.engines = ["pool", "act", "pe", "dma"]
    self.cycle2event = {engine : {} for engine in self.engines}
    self.toEventIds = {}
    print("INFO: parsing %s" % logFile)
    lineCount = 0
    with open(self.logFile) as fh:
      for line in fh:
        match = re.match('^(\d+) : tpb\d+\.([^ ]+) : Execute PC=(\S+) opcode=(\S+)(.*)', line)
        if match:
          (mode, event) = ('', '')
          (cycle, engine, pc, opcode, suffix) = match.groups()
          match = re.search('set_mode=(\S+) set_event=(\S+)', suffix)
          if match:
            (mode, event) = match.groups()
          if engine == 'pool_seq':
            engine = 'pool'
          if engine == 'angel':
            engine = 'dma'
          cycle = int(cycle)
          if cycle >= self.cycleRange[0] and cycle <= self.cycleRange[1]:
            e = InklingEvent(cycle, engine, pc, opcode, mode, event)
            self.events.append(e)
            self.cycle2event[engine][cycle] = e
        else:
          match = re.match('^Cycles: (\d+)', line)
          if match:
            self.numCycles = int(match.groups()[0])
        lineCount += 1
        if lineCount % 100000 == 0:
          print(".", end='', flush=True)
      print()


  e2c = {
    "pe"    : "red",
    "pool"  : "orange",
    "act"   : "blue",
    "dma" : "green",
    }
  def engine2color(self, engine):
    return InklingProfile.e2c.get(engine, "black")
  def getNumCycles(self):
    return self.numCycles
  
  def getEngineFromY(self, y):
    for yidx in range(len(self.engines)):
      if yidx - 0.3 <= y and y <= yidx + 0.3:
        return  self.engines[yidx]
    return None

  def getEventByXY(self, x, y):
    engine = self.getEngineFromY(y)
    if engine == None:
      return None
    for tol in range(5):
      for sign in [1, -1]:
        cycle = int(round(x + sign * tol))
        e = self.cycle2event[engine].get(cycle, None)
        if e != None:
          return e
    return None
  
  def calcEventIdGraph(self):
    self.toEventIds = {}
    inFlight = {}
    for eIdx in range(len(self.events)):
      e = self.events[eIdx]
      instr = self.tongaProgram.getInstr(e.engine, e.pc)
      if instr != None:
        waitEvents, sendEvents = instr.getEvents()
        for we in waitEvents:
          senderIdx = inFlight.pop(we, -1)
          if senderIdx > -1:
            if self.toEventIds.get(senderIdx, None) == None:
              self.toEventIds[senderIdx] = []
            self.toEventIds[senderIdx].append((eIdx, we))
            #print("DEBUG: ", self.toEventIds)
        for se in sendEvents:
          inFlight[se] = eIdx
    #print("DEBUG: event graph  %s" % str(self.toEventIds))
  
  def plotProfile(self, outFile):
    ylabels = self.engines
    y = [y for y in range(len(ylabels))]
    #fig = plt.figure(figsize=(self.geometry))
    fig, axarr = plt.subplots(2, sharex=True, figsize=(self.geometry))
    axPeUtil, axEvents  = axarr
    
    
    print("INFO: processing %d instructions" % len(self.events))
    eventCount = 0
    peCycles = []
    peUtil = [0]
    peUtilTot = [0]
    firstCycle = -1
    opsTot = 0
    for eIdx in range(len(self.events)):
      e = self.events[eIdx]
      engine = e.engine
      color = self.engine2color(engine)
      yval = ylabels.index(engine)
      xval = int(e.cycle)
      instr = self.tongaProgram.getInstr(engine, e.pc)
      #if instr.getInstrType() == 'MATMUL': 
      #print("DEBUG: got  instruction %s  engine %s  pc %s" % (str(instr), engine, e.pc))
      if len(peCycles) == 0:
        firstCycle = xval
        peCycles.append(firstCycle)
      if instr != None:
        #print("DEBUG: %s %s  instr events  %s" % (instr.getInstrType(), e.pc, instr.getEvents()))
        color = instr.getColor()
        instrCycles = instr.getWaveCycles()
        if instrCycles > 1:
          axEvents.plot([xval, xval+instrCycles], [yval-0.3, yval-0.3], color=color, linestyle='-', linewidth=2)
          axEvents.plot([xval, xval+instrCycles], [yval+0.3, yval+0.3], color=color, linestyle='-', linewidth=2)
          axEvents.plot([xval+instrCycles, xval+instrCycles], [yval-0.3, yval+0.3], color=color, linestyle='-', linewidth=2)
          if self.verbose:
            axEvents.text(xval+0.1, yval-0.1, "pc=%s\ncycles=%d" % (e.pc, instrCycles), color=color)
        if instr.getInstrType() == 'MATMUL':
          peuVal = 100.0*instr.getOPC() / 128 / 64 / 2
          waveCycles = instr.getWaveCycles()
          div = xval - firstCycle
          if div == 0:
            div = 1
          UtilTot1 = 100.0 * opsTot / 128 / 64 / 2 / div
          opsTot += instr.getOpCount()
          UtilTot2 = 100.0 * opsTot / 128 / 64 / 2 / (xval - firstCycle + waveCycles)
          peCycles  += [xval-0.1,   xval, xval+waveCycles, xval+waveCycles+0.1]
          peUtil    += [0,        peuVal,          peuVal,                   0]
          peUtilTot += [UtilTot1, UtilTot1,      UtilTot2,            UtilTot2]
      axEvents.plot([xval, xval], [yval-0.3, yval+0.3], color=color, linestyle='-', linewidth=2)
      
      # Plot events
      if self.toEventIds.get(eIdx, None) != None:
        for toIdx, eventId in self.toEventIds[eIdx]:
          toE = self.events[toIdx]
          toCycle = int(toE.cycle)
          toEngine = toE.engine
          toYval = ylabels.index(toEngine)
          xArr = xval+ instrCycles
          yArr = yval
          xDelta = toCycle - xval-instrCycles
          yDelta = toYval - yval
          #axEvents.arrow(xArr, yArr, xDelta, yDelta,
          #              length_includes_head=True,
          #              #head_width=1, head_length=2,
          #              fc='k', ec='k')
          axEvents.annotate("",
            xy=(xArr, yArr), xycoords='data',
            xytext=(xArr+xDelta, yArr+yDelta), textcoords='data',
            arrowprops=dict(arrowstyle="<-, head_width=0.5, head_length=1.5", linestyle="dotted",
                            color="black",
                            patchB=None,
                            shrinkB=0,
                            #connectionstyle="arc3,rad=0.3",
                            ))
          axEvents.text(xArr + 0.5 * xDelta, yArr + 0.5 * yDelta, "0x%x" % eventId)
      
      eventCount += 1
      if eventCount % 100 == 0:
        print("\r%7.3f %%" % (100.0 * eventCount / len(self.events)), end='', flush=True)
      #if eventCount % 1000 == 0:
      #  break
    print()
    
    axEvents.set_yticks(y)
    axEvents.set_yticklabels(ylabels)
    axEvents.grid(True)
    axEvents.set_xlabel('Cycle')
    axEvents.set_ylabel('Engine')
    #axEvents.set_title('Inkling execution profile %s' % self.logFile)
    
    # PE utilization
    axPeUtil.grid(True)
    axPeUtil.set_ylabel('PE Utilization [%]')
    axPeUtil.set_ylim([-2, 102])
    if len(peCycles) > 1:
      handleInst, = axPeUtil.plot(peCycles, peUtil, label='Instantaneous')
      handleCum, = axPeUtil.plot(peCycles, peUtilTot, color='red', label='Cumulative')
      axPeUtil.legend(handles=[handleInst, handleCum])

    plt.tight_layout()
    plt.savefig(outFile)
    print("INFO: wrote  %s" % (outFile))
    if self.show:
      #os.system("firefox %s" % (outFile))

      axEvents.set_title('')
      annot = axEvents.annotate("", xy=(0,0), xytext=(20,-60),textcoords="offset points",
                          bbox=dict(boxstyle="round", fc="w"),
                          arrowprops=dict(arrowstyle="->"))
      annot.set_visible(False)

      def update_annot(e, x, y):
        text = str(e)
        engine = e.engine
        instr = self.tongaProgram.getInstr(engine, e.pc)
        if instr != None:
          text += "\n" + str(instr)
          #annot.get_bbox_patch().set_facecolor(instr.getColor())
          annot.get_bbox_patch().set_edgecolor(instr.getColor())
        annot.xy = (x,y)
        annot.set_text(text)
        annot.set_family('monospace')
        annot.get_bbox_patch().set_alpha(0.95)
        print(text)
        print()

      def hover(event):
        vis = annot.get_visible()
        if event.inaxes == axEvents:
          x, y = event.xdata, event.ydata
          e = self.getEventByXY(x, y)
          if e != None:
            update_annot(e, x, y)
            annot.set_visible(True)
            fig.canvas.draw_idle()
          else:
            if vis:
              annot.set_visible(False)
              fig.canvas.draw_idle()

      fig.canvas.mpl_connect("motion_notify_event", hover)      
      plt.show()
      #outFileZoom = outFile[:-4] + "-zoom.svg"
      #plt.savefig(outFileZoom)
      #print("INFO: wrote  %s" % (outFileZoom))

  def printEventStatistics(self):
    event2count = {}
    print("\nEvent sender and receiver list:")
    for senderIdx in sorted(self.toEventIds):
      recList = self.toEventIds[senderIdx]
      assert len(recList) == 1  # only 1 instruction can wait for this sender
      receiverIdx, eventId = recList[0]
      e1 = self.events[senderIdx]
      engine1 = e1.engine
      c1 = e1.cycle
      instrSender = self.tongaProgram.getInstr(engine1, e1.pc)
      e2 = self.events[receiverIdx]
      engine2 = e2.engine
      c2 = e2.cycle
      instrReceiver = self.tongaProgram.getInstr(engine2, e2.pc)
      
      count = event2count.get(eventId, 0)
      event2count[eventId] = count + 1
      print("  Engine %-4s instr %-10s sent event %3d to engine %-4s instr %-10s  Distance  cycles %6d  waves %4d    Abs cycles sender %8d receiver %8d" %
            (engine1, instrSender.instrType, eventId, engine2, instrReceiver.instrType, c2 - c1, receiverIdx - senderIdx, c1, c2))
    
    print("\n  Event  Count")
    for eventId in sorted(event2count):
      print("  %4d  %4d" % (eventId, event2count[eventId]))


tongaProgram = TongaProgram(args.tpb)


if args.event_statistics:
  p = InklingProfile(args.log, tongaProgram, args.verbose, [0, 1e9], args.show, args.geometry)
  p.calcEventIdGraph()
  p.printEventStatistics()
else:
  p = InklingProfile(args.log, tongaProgram, args.verbose, args.cycle_range, args.show, args.geometry)
  if args.long > 0:
    totalCycles = p.getNumCycles()
    cycleStep = int(args.long)
    pids = []
    pngs = []
    for i in range(int((totalCycles + cycleStep - 1) / cycleStep)):
      outPng = "out_profile-%d.png" % i
      pngs.append(outPng)
      pid = os.fork()
      #pid = 0
      if pid == 0:
        pi = InklingProfile(args.log, tongaProgram, args.verbose, [i*int(cycleStep), (i+1)*int(cycleStep)], False, args.geometry)
        pi.plotProfile(outPng)
        sys.exit(0)
      else:
        pids.append(pid)
    for pid in pids:
      os.wait()
    outPng = "out_profile.png"
    cmd = "convert -append %s %s" % (" ".join(pngs), outPng)
    print("INFO: executing " + cmd)
    os.system(cmd)
    if args.show:
      os.system("firefox %s" % (outPng))  

  else:
    p.calcEventIdGraph()
    p.plotProfile("out_profile.svg")
