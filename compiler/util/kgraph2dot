#!/usr/bin/env python3

# Copyright (C) 2018, Amazon.com. All Rights Reserved
#
# Kgraph visualization
#
import argparse
import os, json, sys
from graphviz import Digraph

parser = argparse.ArgumentParser()
parser.add_argument('--json', help='Json Kgraphs to visualize', nargs='+', default=[])
parser.add_argument('--verbose', help='Verbose node content', action='store_true', default=False)
parser.add_argument('--show', help='Invoke firefox on teh created graphs', action='store_true', default=False)
parser.add_argument('--engine_subgraphs', help='Isolate waveopts into subgraph per engine for faster rendering', action='store_true', default=False)
parser.add_argument('--waveop_range', help='Display only subset of waveops, default 0 1e6', type=int, nargs=2, default=[0,1000000])

args = parser.parse_args()

class KgraphJson(object):
  def __init__(self, jsonFile, verbose, engineSubgraphs, waveOpRange, show):
    self.jsonFile = jsonFile
    self.verbose = verbose
    self.show = show
    self.engineSubgraphs = engineSubgraphs
    self.waveOpRange = waveOpRange
    with open(self.jsonFile) as fh:
      self.jsonData = json.load(fh)
    self.engineTypes = ["PE", "ACT", "POOL", "SP"]

  t2c = {
    "Conv"              : "red",
    "MaxPool"           : "orange",
    "AvgPool"           : "orange",
    "ScaleAdd"          : "orange",
    "TensorTensor"      : "orange",
    "TensorScalar"      : "orange",
    "TensorScalarPtr"   : "orange",
    "BiasAdd"           : "blue",
    "ResAdd"            : "cyan",
    "Const"             : "green",
    # Waveops
    "MatMul"            : "red",
    "SBAtomFile"        : "green",
    "SBAtomSave"        : "brown",
    "Pool"              : "orange",    
    "RegLoad"           : "cyan",    
    "RegStore"          : "green",    
    }
  def type2color(self, layerType):
    return KgraphJson.t2c.get(layerType, "black")

  w2e = {
    "Activation"        : "ACT",
    "MatMul"            : "PE",
    "Pool"              : "POOL",
    "ScaleAdd"          : "POOL",
    "TensorTensor"      : "POOL",
    "TensorScalar"      : "POOL",
    "TensorScalarPtr"   : "POOL",
    "RegLoad"           : "POOL",    
    "RegStore"          : "POOL",    
    "ResAdd"            : "ACT",
    "SBAtomFile"        : "SP",
    "SBAtomSave"        : "SP",
    }
  def waveopt2engine(self, waveopType):
    return KgraphJson.w2e.get(waveopType, "SP")
  
  def getWaveoptEngine(self, layer):
    eng = layer.get("engine", None)
    if eng == None:
      layerType = layer["waveop_type"]
      engine = self.waveopt2engine(layerType)
      return engine
    else:
      for engine in self.engineTypes:
        if engine in eng.upper():
          return engine
      raise RuntimeError("ERROR: failed to identify engine for waveopt %s" % layer)
  
  def plotLayers(self):
    if not "layers" in self.jsonData:
        return

    dot = Digraph(comment="writeDot")
    for layer in self.jsonData["layers"]:
      # node
      attrs = {}
      nodeName = layer["layer_name"]
      layerType = layer["layer_type"]
      shape = layer["ofmap_shape"]
      dotText = "%s\n%s\n%s" % (layerType, nodeName, shape)
      if self.verbose:
        dotText = "\n".join(["%s : %s" % (k, v) for k,v in sorted(layer.items())]) 
      attrs["color"] = self.type2color(layerType)
      attrs["shape"] = "rect"
      dot.node(nodeName, dotText, attrs)
      #print(dot.source)
      # edge
      for prevNode in layer["previous_layers"]:
        edgeAttrs = {}
        dot.edge(prevNode, nodeName, "", edgeAttrs)
        #print(dot.source)
    dot.format = "svg"
    jsonIn = self.jsonFile
    dotOut = jsonIn[:-5] + "-layers.dot"
    dot.render(dotOut)
    print("INFO: wrote  %s.%s" % (dotOut, "svg"))
    if self.show:
      os.system("firefox %s.%s" % (dotOut, "svg"))

  def plotWaveops(self):
    dot = Digraph(comment="writeDot")
    if "waveops" in self.jsonData:
      
      numWavOps = len(self.jsonData["waveops"])
      minRange = self.waveOpRange[0]
      maxRange = self.waveOpRange[1]
      self.jsonData["waveops"] = self.jsonData["waveops"][minRange:maxRange]
      print("INFO: processing waveops %d to %d out of %d" % (minRange, maxRange, numWavOps), flush=True)
      
      # Rank
      node2rank = {}
      if False:
        for engine in ["PE"]:
          ops = []
          for layer in self.jsonData["waveops"]:
            nodeName = layer["waveop_name"]
            layerType = layer["waveop_type"]
            if self.getWaveoptEngine(layer) == engine:
              ops.append(nodeName)
          rank = 1
          for i in range(0, len(ops)):
            node2rank[ops[i]] = rank
            rank += 1

      validOps = set([layer["waveop_name"] for layer in self.jsonData["waveops"]])
      
      for layer in self.jsonData["waveops"]:
        # node
        attrs = {}
        nodeName = layer["waveop_name"]
        layerType = layer["waveop_type"]
        try:
            layerOrder = layer["order"]
            layerOrder = "  " + str(layerOrder)
        except:
            layerOrder = ""
        dotText = "%s%s\n%s" % (layerType, layerOrder, nodeName)
        if self.verbose:
          dotText = "\n".join(["%s : %s" % (k, v) for k,v in sorted(layer.items())]) 
        attrs["color"] = self.type2color(layerType)
        attrs["shape"] = "rect"
        if nodeName in node2rank:
          attrs["rank"] = str(node2rank[nodeName])
        dot.node(nodeName, dotText, attrs)
        #print(dot.source)
        # edge
        edgeIdx = 0
        for prevNode in layer["previous_waveops"]:
          if prevNode in validOps:
            edgeAttrs = {}
            edgeAttrs["weight"] = "1"

            if "previous_event_ids" in layer:
              if len(layer["previous_event_ids"]) > edgeIdx:
                # events
                eventId = layer["previous_event_ids"][edgeIdx]
                if eventId > -1:
                  edgeAttrs["label"] = "E %d" % eventId
                  edgeAttrs["color"] = "blue"
                  edgeAttrs["weight"] = "100"
                  edgeAttrs["minlen"] = "2"

            elif "previous_syncs" in layer:
              if len(layer["previous_syncs"]) > edgeIdx:
                # events
                prevSync1 = layer["previous_syncs"][edgeIdx]
                prevSync2 = prevSync1["value0"]
                if prevSync2["sync_type"] == "event":
                  evtId = prevSync2["event_id"]
                  # print("sync ev: " + evtId)
                  evtIdNum = int(evtId)
                  if evtIdNum > -1:
                    edgeAttrs["label"] = ("E" + evtId)
                    edgeAttrs["color"] = "blue"
                    edgeAttrs["weight"] = "100"
                    edgeAttrs["minlen"] = "2"
                elif prevSync2["sync_type"] == "semaphore":
                  sync = prevSync2["queue"] + ":" + prevSync2["trig_ord"]
                  # print("sync sem: " + sync)
                  edgeAttrs["label"] = sync
                  edgeAttrs["color"] = "blue"
                  edgeAttrs["weight"] = "100"
                  edgeAttrs["minlen"] = "2"
                else:
                  raise RunTimeError(
                    "ERROR: sync from node %s to node %s must be %s event or semaphore",
                    % (layer["waveop_name"], prevNode["waveop_name"]))

            dot.edge(prevNode, nodeName, "", edgeAttrs)
            #print(dot.source)          
            edgeIdx += 1
          else:
            print("WARNING: ignoring previous waveopt outside of range  " + prevNode)

      # subgraph
      if self.engineSubgraphs:
        if False: #  Base simple subgraph
          for engine in self.engineTypes:
            with dot.subgraph(name="cluster_" + engine) as subGraph:
              subGraph.attr(color="purple")
              subGraph.attr(label=engine)
              for layer in self.jsonData["waveops"]:
                layerType = layer["waveop_type"]
                if self.getWaveoptEngine(layer) == engine:
                  nodeName = layer["waveop_name"]
                  subGraph.node(nodeName)
        if True:
          nodeAndType = []
          engineNodeCnt = {}
          for engineType in self.engineTypes:
            engineNodeCnt[engineType] = 0

          for layer in self.jsonData["waveops"]:
            nodeName = layer["waveop_name"]
            layerType = layer["waveop_type"]
            engineType = self.getWaveoptEngine(layer)
            nodeAndType.append([nodeName, engineType])
            engineNodeCnt[engineType] += 1

          for engine in self.engineTypes:
            if engineNodeCnt[engine] == 0:
                continue
            with dot.subgraph(name="cluster_" + engine) as subGraph:
              subGraph.attr(color="purple")
              subGraph.attr(label=engine)
              for i in range(len(nodeAndType)):
                nodeName, engineType = nodeAndType[i]
                tNode = engine + "-" + nodeName
                subGraph.node(tNode, color="white", style="invis", label="")
                if i > 0:
                  prevNodeName, preEngineType = nodeAndType[i-1]
                  tNodePrev = engine + "-" + prevNodeName
                  subGraph.edge(tNodePrev, tNode, "", {"color" : "white"})
                if engineType == engine:
                  subGraph.node(nodeName)
                  subGraph.edge(tNode, nodeName, "", {"color" : "white"})
        # Serialization edges
        if False:
          for engine in self.engineTypes:
            edgeAttrs = {}
            ops = []
            for layer in self.jsonData["waveops"]:
              nodeName = layer["waveop_name"]
              layerType = layer["waveop_type"]
              if self.getWaveoptEngine(layer) == engine:
                ops.append(nodeName)
            edgeAttrs["color"] = "yellow"
            for i in range(1, len(ops)):
              dot.edge(ops[i-1], ops[i], "", edgeAttrs)
      
      
      dot.format = "svg"
      jsonIn = self.jsonFile
      dotOut = jsonIn[:-5] + "-waveops.dot"
      dot.render(dotOut)
      print("INFO: wrote  %s.%s" % (dotOut, "svg"))
      if self.show:
        os.system("firefox %s.%s" % (dotOut, "svg"))


for jsonFile in args.json:
  kj = KgraphJson(jsonFile, args.verbose, args.engine_subgraphs, args.waveop_range, args.show)
  kj.plotLayers()
  kj.plotWaveops()
