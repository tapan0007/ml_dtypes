#!/usr/bin/env python3

import numpy as np
import sys, os
import argparse
sys.path.insert(0, os.environ["KAENA_PATH"] + "/compiler/tffe")
from NpUtils import NpUtils as npu
from npy_bf16_fp32_convert import ConvertBFP16FP32

parser = argparse.ArgumentParser()
parser.add_argument('--gold', help='Golden/reference file. Used as base for the computing relative diference',
                    default="gold.npy")
parser.add_argument('--new', help='New values', default="new.npy")
parser.add_argument('--csv', help='Write golden values and difference in matrix form (CSV)', action='store_true', default=False)
parser.add_argument('--verbose', help='Verbosity level, 0 exit code only (0 allclose match, 1 mismatch), 1 status line, 2 default with histograms and summaries,  3 individual values',
                    default=2)
parser.add_argument('--binary_match', help='Compare binary content, no tolerance (--tolerance is ignored)',
                    action='store_true', default=False)
parser.add_argument('--tolerance', help='Relative in % and absolute, default is 1 % and 1e-5',
                    type=float, nargs=2, default=[1, 1e-5])

args = parser.parse_args()

if not os.path.isfile(args.gold):
  raise("ERROR: missing file --gold ")
if not os.path.isfile(args.new):
  raise("ERROR: missing file --new ")

if args.gold.endswith(".bin"):
  dtype='float16'  # ok for now
  gold = np.fromfile(args.gold, dtype=dtype)
else:
  gold = np.load(args.gold)
if args.new.endswith(".bin"):
  new = np.fromfile(args.new, dtype=gold.dtype)
  try:
    new = new.reshape(gold.shape)
  except:
    print("WARNING: failed to reshape file %s from shape %s to %s" % (args.new, new.shape, gold.shape))
else:
  new = np.load(args.new)

verbose = int(args.verbose)

# If this is bfloat16, upcast to fp32 so we can compare the numbers
if gold.dtype == '|V2':
  gold = ConvertBFP16FP32(gold)
if new.dtype == '|V2':
  new = ConvertBFP16FP32(new)

if gold.shape != new.shape:
  print("ERROR: shapes differ, gold %s, new %s" %(gold.shape, new.shape))
  if verbose >= 3:
    gold1 = gold.flatten()
    new1 = new.flatten()
    print("  %-5s  %-12s  %-12s    %s" % ("Index", "Gold", "New", "Diff"))
    for i in range(max(gold1.size, new1.size)):
      if i < gold1.size:
        valG = "%12g" % gold1[i]
      else:
        valG = "None"
      if i < new.size:
        valN = "%12g" % new1[i]
      else:
        valN = "None"
      if i < min(gold1.size, new1.size):
        valDiff = "%12g" % (new1[i] - gold1[i])
      else:
        valDiff = "Unknown"
      print("  %-5d  %12s  %12s    %s" % (i, valG, valN, valDiff))
        
  else:
    print("Use --verbose 3 to see the content anyway")
  exit(2)

diffAbs = new.astype(np.float64) - gold.astype(np.float64)
# Avoid nan in relative difference reporting
goldFloat64NonZero = gold.astype(np.float64)
for i,v in np.ndenumerate(goldFloat64NonZero):
  if abs(goldFloat64NonZero[i]) < 1e-6:
    goldFloat64NonZero[i] = 1
diffRel = 100 * diffAbs.astype(np.float64) / goldFloat64NonZero

if verbose >= 1:
  print("Comparing")
  print("GOLD  %-10s %-8s %s" % (gold.shape, gold.dtype, args.gold))
  print("NEW   %-10s %-8s %s" % (new.shape, new.dtype, args.new))

if verbose >= 3:
  print("\nDetailed differences:")
  print("%-20s %-12s %-12s  %-12s %-12s" % ("Index", "Gold", "New", "Rel diff [%]", "Abs diff"))
  for index, g in np.ndenumerate(gold):
    n = new[index]
    da = diffAbs[index]
    dr = diffRel[index]
    print("%-20s %12g %12g  %12.2f%% %12g" % (str(index), g, n, dr, da))
  
if args.csv:
  shape = gold.shape
  for i in range(shape[1]):
    print("C=%d"%i)
    for j in range(shape[2]):
      for k in range(shape[3]):
        print("%12g,"%gold[0, i, j, k], end="")
      print(",", end="")
      for k in range(shape[3]):
        #print("%2.2f%%,"%diffRel[0, i, j, k], end="")
        print("%12g,"%diffAbs[0, i, j, k], end="")
      print("")

 # Histograms
if verbose >= 2:
  def printHistogram(text, arr):
    print(text)
    (counts, values) = np.histogram(arr)
    step = 60 / max(counts)
    for (count, value) in zip(counts, values):
      print("  %12g " % value, "#" * int(count * step + 0.49999), count)
  print("\nHistograms:")
  try:
    printHistogram("Gold", gold)
  except Exception as e:
    print("Warning: Failed to print histogram: %s" % str(e))
  try:
    printHistogram("New", new)
  except Exception as e:
    print("Warning: Failed to print histogram: %s" % str(e))

if verbose >= 2:
  print("\nStatistics")
  print("%-20s %12s %12s  %12s %12s" % ("Relative Error (%):", "mean", "std", "min", "max"))
  print("%-20s %12.2f %12.2f  %12.2f %12.2f" % ("", diffRel.mean(), diffRel.std(), diffRel.min(), diffRel.max()))

  print("%-20s %12s %12s  %12s %12s" % ("Absolute Error:", "mean", "std", "min", "max"))
  print("%-20s %12g %12g  %12g %12g" % ("", diffAbs.mean(), diffAbs.std(), diffAbs.min(), diffAbs.max()))

if args.binary_match:
  goldBytes = gold.tobytes()
  newBytes = new.tobytes()
  numBytes = len(goldBytes)
  # Assert is fine since mismatching lengths are handled by shape comparison earlier
  assert numBytes == len(newBytes)
  for i in range(numBytes):
    if goldBytes[i] != newBytes[i]:
      if verbose >= 1:
        print("ERROR: Binary match FAIL at byte %d of %d : gold %s != new %s" % (
                i, numBytes, goldBytes[i], newBytes[i]))
      exit(1)
  if verbose >= 1:
    print("INFO: Binary match PASS by comparing %d bytes" % numBytes)
  exit(0)

else:
  (tolr, tola) = args.tolerance
  resAllclose = npu.allclose(new, gold, tolr/100, tola, equal_nan_inf=True, verbose=verbose)
  #resAllclose = np.allclose(new, gold, tolr/100, tola)
  if verbose >= 1:
    #print("Allclose info tolerance relative %g %%  absolute %g : %s" % (tolr, tola, resAllclose))
    print("Allclose gold %s vs new %s result is %s (%s rel tolerance %g %% of max, abs tolerance %g)\n" 
            % (os.path.basename(args.gold), os.path.basename(args.new),
                "PASS" if resAllclose else "FAIL", 
                "WITHIN" if resAllclose else "OUTSIDE", 
                tolr, tola))
  exit(0 if resAllclose else 1)
