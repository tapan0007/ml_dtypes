#!/usr/bin/env python3

# Copyright (C) 2017, Amazon.com. All Rights Reserved
#
# Basic minimal suite of TF to Inkling tests
#
# Examples
#   Existence test
#     /bin/rm -rf [0-9]* ; ./RunAll --verbose --test 0-1conv0
#   All tests
#     /bin/rm -rf [0-9]* ; ./RunAll --verbose
#

import os, sys, re, shutil, signal, psutil
import argparse
import multiprocessing as mp
import time
import multiprocessing
import test_list


kPath = os.environ.get('KAENA_PATH')
kePath = os.environ.get('KAENA_EXT_PATH')
iPath = os.environ.get('INKLING_PATH')


class Logger(object):
  def __init__(self, logFile):
    self.default = sys.stdout
    self.log = open(logFile, "w")
  def write(self, msg):
    self.default.write(msg)
    self.log.write(msg)  
  def flush(self):
    self.default.flush()
    self.log.flush()  
sys.stdout = Logger('log-RunAll.txt')
sys.stderr = Logger('log-RunAll.txt')

print("\nINFO: started as  ", " ".join(sys.argv))


if kPath == None or kePath == None or iPath == None or \
    not os.path.isdir(kPath) or not os.path.isdir(kePath) or not os.path.isdir(iPath):
  print("ERROR: make sure KAENA_PATH, KAENA_EXT_PATH, and INKLING_PATH environment is set");
  exit(1)

parser = argparse.ArgumentParser()
parser.add_argument('--level', help='Run tests upto this level, default 4. This defines the base set of tests', type=int, default=4)
parser.add_argument('--select', help='Select a specific tests: waived_only, not_waived", default any. This reduces test set from defined by --level', default="any")
parser.add_argument('--test', help='Run specific tests (list). This overrides --level, --select', nargs='+', default=[])
parser.add_argument('--test_re', help='Similar to --test but select by regexp instead of test name; the --test and --test_re are cumulative", default []', nargs='+', default=[])
parser.add_argument('--filter', help='Like --select, but it is applied after --test, --test_re', default="any")
parser.add_argument('--verbose', help='Verbose output', action='store_true', default=False)
parser.add_argument('--show_only', help='Print list of selected tests and exit', action='store_true', default=False)
parser.add_argument('--report_only', help='Print QoR report for the logs in teh current directory', action='store_true', default=False)
parser.add_argument('--parallel', help='Run concurrently, default is number of cores', type=int, default=multiprocessing.cpu_count())
parser.add_argument('--parallel_streams_for_wave', help='run execution engines in parallel', action='store_true', default=True)
parser.add_argument('--timeout', help='Timeout for each test, default 3600', type=int, default=3600)
parser.add_argument('--inkling_debugflags', help='Pass some arguments to sim, optional', nargs='+', default=[])
parser.add_argument('--small_first', help='Start N small tests before next large one, default 4', type=int, default=4)

args = parser.parse_args()
verbose = args.verbose
level = args.level
parallel = args.parallel
select = args.select
selectSet = set(["any", "waived_only", "not_waived"])
parallelStreamsForWave = args.parallel_streams_for_wave
inklingArgs = " ".join(args.inkling_debugflags)
if not select in selectSet:
  print("\nERROR: --select must be one of " + str(selectSet))
  sys.exit(1)
if not args.filter in selectSet:
  print("\nERROR: --filter must be one of " + str(selectSet))
  sys.exit(1)

if verbose:
  print("\nINFO: started as  ", " ".join(sys.argv))


def getLevel(testName):
  return int(testName[0])

def calcIsWaived(testName, testWaiver):
  # Linear search for now is ok
  for regexp,replacementStatus in testWaiver:
    if re.search(regexp, testName):
      return True
  return False


def selectTests(testConfigMap, testWaiver, arglevel, argTest, argTestRe, argSelect, argFilter):
  testList = []
  # Pre-select by level and the select method
  if len(argTest) == 0 and len(argTestRe) == 0:
    for testName in sorted(testConfigMap):
      isWaived = calcIsWaived(testName, testWaiver)
      if getLevel(testName) <= level:
        if argSelect == "any" or (isWaived and argSelect == "waived_only") or ((not isWaived) and argSelect == "not_waived"):
          testList.append(testName)
  else:
    # Check that all --test exist
    if len(argTest) > 0:
      wrongTests = []
      for t in argTest:
        if not t in testConfigMap:
          wrongTests.append(t)
      if len(wrongTests) > 0:
        print("ERROR: the --test %s   do not exist" % str(wrongTests))
        sys.exit(1)
      testList = argTest
    # Add--test_re
    if len(argTestRe) > 0:
      for testName in sorted(testConfigMap):
        for regexp in argTestRe:
          if re.search(regexp, testName):
            testList.append(testName)
  # Filter by the --filter method
  testListFiltered = []
  for testName in testList:
    isWaived = calcIsWaived(testName, testWaiver)
    if argFilter == "any" or (isWaived and argFilter == "waived_only") or ((not isWaived) and argFilter == "not_waived"):
      testListFiltered.append(testName)
  # Remove duplicates
  testListFinal = sorted(list(set(testListFiltered)))
  return testListFinal


def runCmd(cmd):
  ret = os.system(cmd)
  return(ret)

###############################################################################
# QoR results for one tests
###############################################################################
class QoR:
  @staticmethod
  def simLogGetCycles(filepath):
    cycles = -1
    elapsedTimeSec = -1
    with open(filepath, 'rb') as fh:
      for lineBinary in fh.readlines():
        line = lineBinary.decode('ascii')
        found = re.search('Cycles:\s+(\d+)', line)
        if found:
          cycles = found.group(1)
        found = re.search('ElapsedTimeSec:\s+([\d.]+)', line)
        if found:
          elapsedTimeSec = found.group(1)
    return int(cycles), float(elapsedTimeSec)

  @staticmethod
  def feLogGetOps(filepath):
    ops = 0
    with open(filepath, 'r') as fh:
      for line in fh:
        match = re.search('INFO: total opcount is (\d+)', line)
        if match:
          ops = int(match.groups(1)[0])
    return ops

  def __init__(self, dirName):
    self.freq = 1e9
    self.testName = dirName
    feLog = self.testName + "/" + "log-fe.txt"
    self.tops = 0
    self.ops = 0
    self.cycles = 0
    self.elapsedTimeSec = -1e-6
    self.cyclesPerSec = 0
    if os.path.isfile(feLog):
      self.ops = QoR.feLogGetOps(feLog)
      for subdir, dirs, files in os.walk(dirName):
        for file in files:
          #print("DEBUG: visited file  " + os.path.join(subdir, file))
          filepath = subdir + os.sep + file
          if re.match(r'log-exec-sg\d+-(wave|tcc)', file):
            #print("DEBUG: processing file  " + os.path.join(subdir, file))
            testName = filepath.split("/")[0]
            assert(testName == self.testName)
            sgCycles, sgElapsedTimeSec = QoR.simLogGetCycles(filepath)
            self.cycles += sgCycles
            self.elapsedTimeSec += sgElapsedTimeSec
    if self.cycles > 0:
      self.tops = 1.0 * self.ops / self.cycles / 1e12 * self.freq
    if self.elapsedTimeSec > 0:
      self.cyclesPerSec = self.cycles / self.elapsedTimeSec

  @staticmethod
  def printHeader():
    print("%-32s  %-16s  %6s  %16s %16s  %16s %16s  %10s  %s" %
          ("Test", "Status", "Tops", "Ops", "SimCycles", "SimTimeSec", "SimCycles/sec", "TotTimeSec", "Description"))
    print("-" * 150)

  def printValues(self, status, testTime, description):
    print("%-32s  %-16s  %6.3f  %16g %16g  %16.3f %16g  %10.1f  %s" %
          (self.testName, status, self.tops, self.ops,
           self.cycles, self.elapsedTimeSec, self.cyclesPerSec,
           testTime, description))


###############################################################################
# Storage for test name, results
###############################################################################
class Ktest:
  def __init__(self, name, dirName, cmd):
    self.name = name
    self.dir = dirName
    self.cmd = cmd
    self.startTime = time.time()
    self.testTime = -1
    self.status = "UNKNOWN"
  def invertStatus(self):
    if self.status == "PASS":
      self.status = "FAIL"
    elif self.status == "FAIL":
      self.status = "PASS"
  def calcRTStatus(self):
    statusFile = self.dir + "/log-rt.txt"
    self.status_rt = "FAIL"
    if os.path.isfile(statusFile):
      with open(statusFile, 'r') as fh:
        for line in fh.readlines():
          match = re.search('INFO: Kaena RT status (.*)', line)
          if match:
            self.status_rt = match.group(1)
  def calcKCCStatus(self):
    statusFile = self.dir + "/log-fe.txt"
    self.status_kcc = "FAIL"
    if os.path.isfile(statusFile):
      with open(statusFile, 'r') as fh:
        for line in fh.readlines():
          match = re.search('INFO: Kaena Compiler status (.*)', line)
          if match:
            self.status_kcc = match.group(1)

  # Middle end or other intermediate status
  def calcAltStatus(self):
    statusFile = self.dir + "/log-me.txt"
    self.altStatus = "None"
    if os.path.isfile(statusFile):
      with open(statusFile, 'r') as fh:
        for line in fh.readlines():
          match = re.search('^PASSED$', line)
          if match:
            self.altStatus = "PASS"

  def calcStatus(self):
    self.calcRTStatus()
    self.calcKCCStatus()
    self.calcAltStatus()
    if not self.status == "TIMEOUT":
      self.status = "PASS"
      if (self.status != self.status_kcc or self.status != self.status_rt):
        self.status = "FAIL"
      if self.name == "0-neg":
        self.invertStatus()

  def calcQoR(self):
    self.qor = QoR(self.dir)
  def passed(self):
    return self.status == "PASS"
  def failed(self):
    return self.status == "FAIL"
  def timedout(self):
    return self.status == "TIMEOUT"
  def exceededTimeout(self, timeout):
    #print("DEBUG: checking test  %s  for timeout  %f > %f" % (self.name, time.time() - self.startTime, timeout))
    return time.time() > self.startTime + timeout
  def setStatusTimeout(self):
    self.status = "TIMEOUT"
  
###############################################################################
# Storage for all tests
###############################################################################
class Ktests:
  def __init__(self, testConfigMap, testList, testWaiver, testTimeout, smallFirst):
    self.testConfigMap = testConfigMap
    self.testList = testList
    self.testWaiver = testWaiver
    self.testTimeout = testTimeout
    self.smallFirst = smallFirst
    self.startTime = time.time()
    self.process2test = {}
    self.name2test = {}
    self.processes = []
    self.numRunning = 0
    self.sleepSec = 1
    self.numPass = 0
    self.numFail = 0
    self.msg = ""
    self.statusCount = 0
    self.testDescriptionREs = []
    testDesriptionFile = os.path.dirname(os.path.realpath(__file__)) + "/test_description.txt"
    with open(testDesriptionFile, 'r') as fh:
      for line in fh:
        match = re.search('(^[^#\s]+)\s+(\S.*)', line)
        if match:
          self.testDescriptionREs.append(match.groups())

  def getNumTests(self):
    return len(self.testList)
    
  def reportStatusWhileRunning(self):
    numAll = self.getNumTests()
    numRun = self.numRunning
    numRunPct = numRun / numAll * 100
    numPass = self.numPass
    numPassPct = numPass / numAll * 100
    numFail = self.numFail
    numFailPct = numFail / numAll * 100
    numOther = numAll - numPass - numFail - numRun
    numOtherPct = numOther / numAll * 100
    if self.statusCount %60 == 0:
      print("\n  #Time    Running    Passed    Failed     Other")
    if self.msg or self.statusCount %10 == 0:
      print("  %6s  %3d %3.0f%%  %3d %3.0f%%  %3d %3.0f%%  %3d %3.0f%%  %s" %
            (int(time.time() - self.startTime),
             numRun, numRunPct, numPass, numPassPct, numFail, numFailPct, numOther, numOtherPct, self.msg),
            flush=True
           )
    self.statusCount += 1
    self.msg = ""

  # check for running proceses
  def checkProcesses(self, sleepLimit):
    newProcesses = []
    finishedProcesses = []
    for p in self.processes:
      if p.is_alive():
        newProcesses.append(p)
        t = self.getTestByProcess(p)
        if t.exceededTimeout(self.testTimeout):
          time.sleep(0.01)
          
          # The terminate does not correctly signal to all
          # transitive child processes so signal explicitly
          try:
            proc = psutil.Process(p.pid)
            children = proc.children(recursive=True)
            for process in children:
              #print("DEBUG: terminating child %d" % process.pid)
              process.send_signal(signal.SIGTERM)
          except psutil.NoSuchProcess:
            #print("DEBUg: missing process")
            pass
          
          #os.kill(p.pid, signal.SIGKILL)
          #os.killpg(os.getpgid(p.pid), signal.SIGKILL)
          p.terminate()
          t.setStatusTimeout()
      else:
        p.join()
        finishedProcesses.append(p)
    self.postprocess(finishedProcesses)
    self.processes = newProcesses
    self.numRunning = len(self.processes)
    self.reportStatusWhileRunning()
    if self.numRunning >= sleepLimit:
      #print(".", end='', flush=True)
      time.sleep(self.sleepSec)
    return(finishedProcesses)

  def getTestByProcess(self, process):
    return self.process2test[process]

  def getTestByName(self, testName):
    return self.name2test[testName]

  def postprocessOneTest(self, t):
    t.calcStatus()
    t.calcAltStatus()
    t.calcQoR()
    if t.passed():
      self.numPass += 1
    if t.failed() or t.timedout():
      self.numFail += 1
    reportStatus = self.calcWaivedStatus(t.name, t.status)
    self.msg += "  %s %s" % (t.name, reportStatus)
    if not t.status == "TIMEOUT":
      t.testTime = time.time() - t.startTime
  

  def postprocess(self, finishedProcesses):
    for p in finishedProcesses:
      t = self.getTestByProcess(p)
      self.postprocessOneTest(t)
  
  def interleaveFrontBack(self, arr, ratio):
    newArr = []
    srcArr = arr.copy()
    while len(srcArr) > 0:
      for i in range(ratio):
        if len(srcArr) > 0:
          newArr.append(srcArr.pop(0))
      if len(srcArr) > 0:
        newArr.append(srcArr.pop(-1))
    return newArr

  # Run tests
  def run(self, parallel, reportOnly):
    self.parallel = parallel
    start_time = time.time()
    self.numRunning = 0
    self.processes = []

    outPrefix = "trivnet_"
    for testName in self.interleaveFrontBack(self.testList, self.smallFirst):
      # Add default NN args
      while len(self.testConfigMap[testName]) < 5:
        self.testConfigMap[testName].append("")
      (nnStruct, nnConfig, nnLabel, nnArgs, rtArgs) = self.testConfigMap[testName]
      if verbose:
        print("\n############## %s ##############" % testName)
      if parallelStreamsForWave and "wave" in testName:
        nnArgs += " --parallel_streams" # forward option to compiler
      # default ref omage
      default_image =  "%sref_input.npy" % outPrefix
      if "trivnet" in nnStruct and "--images" not in nnArgs:
          nnArgs += " --images %s " % default_image # default if none..
      if "trivnet" in nnStruct and "--input_files" not in rtArgs:
          rtArgs += " --input_files %s " % default_image # default if none..

      rtArgs += ' --inkling_debugflags "%s"' % inklingArgs # add passed inkling args to rt Args
      cmd = 'ulimit -t %d; ulimit -H -t %d; mkdir %s && cd %s && make -f  $KAENA_PATH/test/e2e/Makefile %s NN_CONFIG=%s OUT_PREFIX=%s NN_NAME=%s NN_ARGS="%s" RT_ARGS="%s"' % (self.testTimeout, self.testTimeout, testName, testName, nnStruct, nnConfig, outPrefix, nnLabel, nnArgs, rtArgs) 
      cmd +=  ' > log-top.txt 2>&1'
      # Remove the old directory
      if not reportOnly:
        if os.path.exists(testName):
          oldDir = "%s-old-%d" % (testName, os.getpid())
          #print("DEBUG: renamed %s to %s and removed it" % (testName, oldDir))
          os.rename(testName, oldDir)
          shutil.rmtree(oldDir)

        while self.numRunning >= self.parallel:
          self.checkProcesses(self.parallel)

        if verbose:
          print("Executing ", cmd)
        else:
          self.msg += "  %s START" % testName
        p = mp.Process(target=runCmd, args=(cmd,))
        #p.daemon = True
        p.start()
        self.numRunning += 1
        self.processes.append(p)
        t = Ktest(testName, testName, cmd)
        self.process2test[p] = t
        self.name2test[testName] = t
      else:
        t = Ktest(testName, testName, cmd)
        self.name2test[testName] = t
        self.postprocessOneTest(t)

    if not reportOnly:
      while self.numRunning > 0:
        self.checkProcesses(0)

    end_time = time.time()
    print("\nDone in %.3f sec" % (end_time - start_time))

  def getTestDescription(self, testName):
    description = "Missing Description"
    for testPattern,Text in self.testDescriptionREs:
      match = re.search(testPattern, testName)
      if match:
        description = Text
    return description

  def calcWaivedStatus(self, testName, status):
    newStatus = status
    newTmpStatus = None
    for regexp,replacementStatus in self.testWaiver:
      if re.search(regexp, testName):
        newTmpStatus = replacementStatus
    if not newTmpStatus == None:
      if status == "FAIL":
        newStatus = newTmpStatus
      elif status == "PASS":
        newStatus = "%s_%s" % (status, newTmpStatus)
    return newStatus

  def calcNumWaivedTest(self):
    numWaived  = 0
    for testName in self.testList:
      t = self.getTestByName(testName)
      reportStatus = self.calcWaivedStatus(testName, t.status)
      if 'WAIVE' in reportStatus and not 'PASS' in reportStatus:
        numWaived += 1
    return numWaived

  def report(self):
    numAll = self.getNumTests()
    numWaived = self.calcNumWaivedTest()
    numPass = self.numPass + numWaived
    numPassPct = numPass / numAll * 100
    print("\nSUMMARY: PASSRATE  %d  %.3f%%  of  %d  (%d were waived)\n" %
          (numPass, numPassPct, numAll, numWaived) )
    
    status2count = {}
    status2test = {}
    for testName in self.testList:
      t = self.getTestByName(testName)
      reportStatus = self.calcWaivedStatus(testName, t.status)
      count = status2count.get(reportStatus, 0)
      status2count[reportStatus] = count + 1
      if not reportStatus in status2test:
        status2test[reportStatus] = []
      status2test[reportStatus].append(testName)
    strStatus = ""
    for status in sorted(status2count):
      strStatus += "%s %d  " % (status, status2count[status])
    print("DETAILED STATUS: ", strStatus)
    
    statusList = sorted(status2test)
    if 'PASS' in statusList:
      statusList.append(statusList.pop(statusList.index('PASS')))
    for status in statusList:
      print("  %s" % status)
      for test in sorted(status2test[status]):
        print("    ", test)
    print("\n")
    
    QoR.printHeader()
    for testName in self.testList:
      t = self.getTestByName(testName)
      testDescription = self.getTestDescription(testName)
      reportStatus = self.calcWaivedStatus(testName, t.status)
      t.qor.printValues(reportStatus, t.testTime, testDescription)

  def dashboard(self, testRe, outFileName):
    with open(outFileName, "w") as fh:
      fh.write("Test description is in  https://sim.amazon.com/issues/kaena-163\n")
      fh.write("%-20s  %-12s  %-12s\n" % ("Test", "MeStatus", "Status"))
      fh.write("-" * 79 + "\n")
      countAll = 0
      countPass = 0
      for testName in self.testList:
        if re.search(testRe, testName):
          t = self.getTestByName(testName)
          fh.write("%-20s  %-12s  %-12s\n" % (testName, t.altStatus, t.status))
          if t.status == 'PASS':
            countPass += 1
          countAll += 1
      if countAll == 0:
        countAll = 1
      fh.write("-" * 79 + "\n" + "PASSRATE  %d of %d  %.3f%%\n" % (countPass, countAll, 100 * countPass / countAll))
    print("INFO: wrote dashboard status into %s" % outFileName)
      
  def plotTops(self, outFile, minTops, normalizeTo, pctLines, keyTests):
    test2tops = {}
    for testName in self.testList:
      t = self.getTestByName(testName)
      tops = t.qor.tops
      if tops >= minTops:
        test2tops[testName] = tops
    labels = sorted(test2tops, key=test2tops.get, reverse=True)
    x = [x for x in range(len(labels))]
    y = [test2tops[t] for t in  labels]
    plt.figure(figsize=(12,8))
    #plt.margins(0.8)
    #plt.subplots_adjust(bottom=0.7)
    plt.xticks(x, labels, rotation='vertical')
    plt.bar(x, y, width=0.5, color = 'blue')
    for p, color in pctLines.items():
      val = p / 100 * normalizeTo
      plt.axhline(y=val, color=color)
      plt.text(-3, val + 0.1, '%g%%' % p, color=color)
    for i,v in enumerate(y):
      color = 'black'
      if labels[i] in keyTests:
        color = 'red'
      plt.text(i-0.3, v+0.5, "%2.0f" % (100 * v / normalizeTo), rotation='vertical', color=color)
    plt.xlabel('NN')
    plt.ylabel('Tops')
    plt.title('TPB performance')
    plt.tight_layout()
    plt.savefig(outFile)
      
  def plotInf(self, outFile, freq, minInfps, maxInfps, keyTests):
    test2infps = {}
    for testName in self.testList:
      t = self.getTestByName(testName)
      cycles = t.qor.cycles
      if cycles > 0:
        infPs = freq / cycles
        if infPs >= minInfps and infPs <= maxInfps:
          test2infps[testName] = infPs
    labels = sorted(test2infps, key=test2infps.get, reverse=True)
    x = [x for x in range(len(labels))]
    y = [test2infps[t] for t in  labels]
    plt.figure(figsize=(12,8))
    plt.xticks(x, labels, rotation='vertical')
    plt.bar(x, y, width=0.5, color = 'blue')
    for i,v in enumerate(y):
      color = 'black'
      if labels[i] in keyTests:
        color = 'red'
      plt.text(i-0.1, v+300, "%.0f" % v, rotation='vertical', color=color)
    plt.xlabel('NN')
    plt.ylabel('Inf [1/s]')
    plt.title('TPB inferences per second')
    plt.tight_layout()
    plt.savefig(outFile)
      
 
###############################################################################
# Execute
testList = selectTests(test_list.testConfigMap, test_list.testWaiver, args.level, args.test, args.test_re, args.select, args.filter)
if args.show_only:
  print("INFO: --show_only mode: selected tests are\n" + "\n".join(testList))
else:
  tests = Ktests(test_list.testConfigMap, testList, test_list.testWaiver, args.timeout, args.small_first)
  tests.run(parallel, args.report_only)
  tests.report()
  tests.dashboard('3-rn50-\d+_wave', "sprint9-dashboard.txt")
  plotQor = False
  try:
    import matplotlib.pyplot as plt
    plotQor = True
  except:
    print("WARNING: matplotlib is not installed, skipped Qor plot")
  if plotQor:
    keyDesigns = ['7-rn50_nne_fp16_wave']
    tests.plotTops("qor_tops.svg", 0.2, 16, {100 : 'lightgreen', 75 : 'yellow', 60 : 'orange'}, keyDesigns)
    tests.plotInf("qor_inf.svg", 1e9, 0, 5000, keyDesigns)
    
