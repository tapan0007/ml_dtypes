#!/usr/bin/env python3

# Copyright (C) 2018, Amazon.com. All Rights Reserved
#
# Kaena neural network executor with mapping to mixed backends.
#

import argparse
import os.path
import sys, json, re
kPath = os.environ.get('KAENA_PATH')
sys.path.insert(0, kPath + "/compiler/tffe")
from NpUtils import NpUtils as npu
from NpTransforms import NpTrans as npt


parser = argparse.ArgumentParser()
parser.add_argument('--nn_graph', help='Graph to execute', default="nn_graph.txt")
parser.add_argument('--tfpb', help='TensorFlow freeze graph file', default="f.pb")
parser.add_argument('--executors', help='Specifies executors per subgraph, e.g., tcc 1 2 3 (implies rest on host, host 0 4 5), default ""',
                    nargs='+', default=[])

args = parser.parse_args()
nnGraphFile = args.nn_graph
tfpbFile = args.tfpb
if not tfpbFile.startswith('/'):
  tfpbFile = '../' + tfpbFile

class NnSubgraph:
  def __init__(self, sgDir, inputs, output):
    self.sgDir = sgDir
    self.inputs = inputs
    self.output = output
  
  def getOutputNpyFile(self):
    return self.output[1]
  def getOutputNpyFileBase(self):
    return self.getOutputNpyFile()[:-4]
  
  # Translate and relink npy files that are inputs to this subgraph
  # Each subgraph produces output in the host format. So just rename npy
  # files A:0.npy to point to ../A:0-out.npy
  def getUpdatedInputs(self):
    newInputs = []
    if self.getSgId() == 0:
      return self.inputs
    for inp,f in zip(self.inputs[::2], self.inputs[1::2]):
      fBase = f[:-4]  # removes .npy
      tfFile = "../%s-out.npy" % fBase
      newInputs += [inp, tfFile]
    return newInputs
  
  # The TPB executor (tcc, wave, waveopt) uses fixed npy files
  # in TPB format. This function finds the ../...-out.npy file
  # converts it to TPB format and links it instead of the original input
  # which is renamed to ./...-orig.npy)
  def overwriteInputFilesInTpbFormat(self):
    newInputs = []
    if self.getSgId() == 0:
      # The inputs for the first subgraph are same as when compiled
      return
    tpbFmapFormat = npt.Formats[npt.SIM][npt.Fmaps]
    tpbWeightFormat = npt.Formats[npt.SIM][npt.Weights]
    for inp,f in zip(self.inputs[::2], self.inputs[1::2]):
      fBase = f[:-4]  # removes .npy
      # Only Fmaps come from the previous subgraph
      tpbInpFile = "%s/%s_%s.npy"      % (self.sgDir, fBase, npt.Formats[npt.SIM][npt.Fmaps])
      if os.path.isfile(tpbInpFile):
        tfFile = "%s-out.npy" % fBase
        # Move the compiler generated input file
        origFile = tpbInpFile.replace(".npy", "-orig.npy")
        os.rename(tpbInpFile, origFile)
        # Translate and write the previous subgraph file
        if os.path.isfile(f):
          npt.copyNpyFileAs(tfFile, npt.TF, npt.SIM, npt.Fmaps, outFile=tpbInpFile)
          print("INFO: translated TF format  %s  to TPB Fmap format  %s" % (tfFile, tpbInpFile))
        else:
          print("ERROR: no tpb output file %s" % tfFile, flush=True)        
        newInputs += [inp, tfFile]
      else:
        print("ERROR: missing TPB-format input file  %s" % tpbInpFile)
        sys.exit(1)
    return newInputs
  
  # The files are shared by op name A, then computed locally as sg00/A-out.npy
  # and linked to parent as A-out.npy which the input for the next subgraph
  # This ensures a subgraph failure is visible in the end result
  def run(self, executor):
    logFile = "log-%s.txt" % executor
    outBase = self.getOutputNpyFileBase()
    tfOutFile = outBase + "-out.npy"
    if executor == "host":
      cmd = "%s/runtime/util/runtime_tf" % kPath
      cmd += "  --tfpb %s" % tfpbFile
      cmd += "  --input_tensors %s" % " ".join(self.getUpdatedInputs())
      cmd += "  --output_tensor %s %s" % (self.output[0], tfOutFile)
      sgOutFile = "%s/%s" % (self.sgDir, tfOutFile)
    elif executor == "tcc" or executor == "wave" or executor == "waveopt":
      self.overwriteInputFilesInTpbFormat()
      cmd = "bash %s/compiler/be/test/RunOne.sh *tgz" % kPath
    #os.chdir(self.sgDir)
    cmd = "cd %s; %s > %s 2>&1" % (self.sgDir, cmd, logFile)
    print("\nINFO: executing %s" % cmd, flush=True)
    os.system(cmd)
    # Translate TPB format back to TF format.
    # To share easily the file is also linked to the parent dir
    if not executor == "host":
      simExt = "simout"
      if executor == "waveopt":
        simExt = "midout"
      tpbFmapFormat = npt.Formats[npt.SIM][npt.Fmaps]
      tpbOutFile = "%s/%s_%s-%s.npy" % (self.sgDir, outBase, tpbFmapFormat, simExt)
      sgOutFile = "%s/%s" % (self.sgDir, tfOutFile)
      if os.path.isfile(tpbOutFile):
        npt.copyNpyFileAs(tpbOutFile, npt.SIM, npt.TF, npt.Fmaps, outFile=sgOutFile)
      else:
        print("ERROR: no tpb output file %s" % tpbOutFile, flush=True)
    if os.path.islink(tfOutFile):
      os.remove(tfOutFile)
      print("INFO: removed stale link %s" % tfOutFile)
    os.symlink(sgOutFile, tfOutFile)
    
  def getSgId(self):
    sgId = int(self.sgDir.replace("sg", ""))
    return sgId

class NnExec:
  def __init__(self, nnGraphFile, tpbFile, executors):
    with open(nnGraphFile) as fh:
      self.nnGraphJsonData = json.load(fh)
    numSubGraphs = len(self.nnGraphJsonData["SubGraphs"])
    self.sgId2executor = {}
    executor = None
    for word in executors:
      if word == "all":
        for sgId in range(numSubGraphs):
          self.sgId2executor[sgId] = executor
      elif re.search('^\d+$', word):
        sgId = int(word)
        self.sgId2executor[sgId] = executor
      else:
        executor = word
    print("INFO: subgraph to executor map  %s" % str(self.sgId2executor), flush=True)
    self.subGraphs = []

  def run(self):
    for sgJson in self.nnGraphJsonData["SubGraphs"]:
      sg = NnSubgraph(sgJson["SubGraphDir"], sgJson["Inputs"],
                      sgJson["Output"])
      self.subGraphs.append(sg)
      sg.run(self.sgId2executor.get(sg.getSgId(), "host"))

  # Return unix exit code
  def check(self):
    lastSg = self.subGraphs[-1]
    outBase = lastSg.getOutputNpyFileBase()
    flowOutFile = outBase + "-out.npy"
    refOutFile = lastSg.getOutputNpyFile()
    cmd = "%s/compiler/util/npy_diff_files --gold %s --new %s" % (kPath, refOutFile, flowOutFile)
    print("INFO: executing %s" % cmd, flush=True)
    ret = os.system(cmd)
    return ret

nnExec = NnExec(nnGraphFile, tfpbFile, args.executors)
nnExec.run()
ret = nnExec.check()
sys.exit(0 if ret == 0 else 1)


