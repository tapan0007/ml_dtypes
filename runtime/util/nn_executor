#!/usr/bin/env python3

# Copyright (C) 2018, Amazon.com. All Rights Reserved
#
# Kaena neural network executor with mapping to mixed backends.
#

import argparse
import os.path
import sys, json, re
sys.path.insert(0, os.environ["KAENA_PATH"] + "/compiler/tffe")
from NpUtils import NpUtils as npu
from NpTransforms import NpTrans as npt

kPath = os.environ.get('KAENA_PATH')

parser = argparse.ArgumentParser()
parser.add_argument('--nn_graph', help='Graph to execute', default="nn_graph.txt")
parser.add_argument('--tfpb', help='TensorFlow freeze graph file', default="f.pb")
parser.add_argument('--executors', help='Specifies executors per subgraph, e.g., tcc 1 2 3 (implies rest on host, host 0 4 5), default ""',
                    nargs='+', default=[])

args = parser.parse_args()
nnGraphFile = args.nn_graph
tfpbFile = args.tfpb
if not tfpbFile.startswith('/'):
  tfpbFile = '../' + tfpbFile

class NnSubgraph:
  def __init__(self, sgDir, inputs, output):
    self.sgDir = sgDir
    self.inputs = inputs
    self.output = output
  
  def getOutputNpyFile(self):
    return self.output[1]
  
  # The files are shared by op name A, then computed locally as sg00/A-out.npy
  # and linked to parent as A-out.npy which the input for the next subgraph
  # This ensures a subgraph failure is visible in the end result
  def run(self, executor):
    logFile = "log-%s.txt" % executor
    outBase = self.getOutputNpyFile()[:-4]
    tfOutFile = outBase + "-out.npy"
    if executor == "host":
      cmd = "%s/runtime/util/runtime_tf" % kPath
      cmd += "  --tfpb %s" % tfpbFile
      cmd += "  --input_tensors %s" % " ".join(self.inputs)
      cmd += "  --output_tensor %s %s" % (self.output[0], tfOutFile)
      sgOutFile = "%s/%s" % (self.sgDir, tfOutFile)
    elif executor == "tcc" or executor == "wave":
      cmd = "bash %s/compiler/be/test/RunOne.sh *tgz" % kPath
    #os.chdir(self.sgDir)
    cmd = "cd %s; %s > %s 2>&1" % (self.sgDir, cmd, logFile)
    print("INFO: executing %s" % cmd, flush=True)
    os.system(cmd)
    # Translate TPB format back to TF format.
    # To share easily the file is also linked to the parent dir
    if not executor == "host":
      tpbFmapFormat = npt.Formats[npt.SIM][npt.Fmaps]
      tpbOutFile = "%s/%s_%s-simout.npy" % (self.sgDir, outBase, tpbFmapFormat)
      sgOutFile = "%s/%s" % (self.sgDir, tfOutFile)
      npt.copyNpyFileAs(tpbOutFile, npt.SIM, npt.TF, npt.Fmaps, outFile=sgOutFile)
    os.symlink(sgOutFile, tfOutFile)
    
  def getSgId(self):
    sgId = int(self.sgDir.replace("sg", ""))
    return sgId

class NnExec:
  def __init__(self, nnGraphFile, tpbFile, executors):
    with open(nnGraphFile) as fh:
      self.nnGraphJsonData = json.load(fh)
    numSubGraphs = len(self.nnGraphJsonData["SubGraphs"])
    self.sgId2executor = {}
    executor = None
    for word in executors:
      if word == "all":
        for sgId in range(numSubGraphs):
          self.sgId2executor[sgId] = executor
      elif re.search('^\d+$', word):
        sgId = int(word)
        self.sgId2executor[sgId] = executor
      else:
        executor = word
    print("INFO: subgraph to executor map  %s" % str(self.sgId2executor))

  def run(self):
    for sgJson in self.nnGraphJsonData["SubGraphs"]:
      sg = NnSubgraph(sgJson["SubGraphDir"], sgJson["Inputs"],
                      sgJson["Output"])
      sg.run(self.sgId2executor.get(sg.getSgId(), "host"))
      
nnExec = NnExec(nnGraphFile, tfpbFile, args.executors)
nnExec.run()


