#!/usr/bin/env python3

# Copyright (C) 2018, Amazon.com. All Rights Reserved


# Kaena qemu Inkling and emulator runtime wrapper

epilog = '''
The command is automatically invoked from RunAll through the nn_executor

The disk image is added to S3 by e.g,
  aws s3 cp /work1/zejdaj/git_repo/qemu_inkling/my_vm.img s3://kaena-vdi/lubuntu_20180525 --profile kaena
and in future we'll use the  kaena-compiler/runtime/util/vdi/vdi_manager.py to create and populate VDIs

There are 2 basic use modes:
 - Single port (--port) which starts qemu, boots its os, loads drivers, starts runtime and performs 1 inference
 - Pool (--pool) whih decouples starting qemu (boot os, add drivers) and the inference

The pool flow is https://issues.amazon.com/issues/kaena-574 . In Summary:

# Start a qemu pool (with 5 qemus, 0 to 4)
  $KAENA_PATH/runtime/util/qemu_rt --pool 7100 7105 --action start_pool > log_pool 2>&1 &
    # The pool ports can be 1 number (eg 5555, ie 1 qemu), 2 for range (8000 8010 means 10 qemus on ports 8000 to 8009), 3+ for a list of individual ports (e.g., 8003 8009 19765).

# Watch till pool completes initialization. It then prints env instructions:
  tail -f log_pool
   # prints 
      INFO: holding quemus <i>. Sleep 10. Use  export KAENA_QEMU_RT_POOL="7100 7105"; RunAll --force_qemu --test ... to run.   Terminate this process to close the qemus

# Use the above command to run regression tests. On small pools running slow tests also use --parallel <num ports ie 5> to make sure timeouts are properly applied
   ( export KAENA_QEMU_RT_POOL="7100 7105"; $KAENA_PATH/test/e2e/RunAll --force_qemu --parallel 5 --level 10 ) > log 2>1 &
     # Multiple runs or users can share the same pool - just remember that the time in the qemu_rt backend is part of the overall job timeout

# To terminate the pool (days later) simply kill the first process and remove pool_* directories where you started the pools

'''

import argparse
import os, sys, stat, time, random
import glob
import pexpect
import socket, errno

print("\nINFO: started as  ", " ".join(["'"+word+"'" if " " in word else word for word in sys.argv]), flush=True)
qiBldPath = os.environ["QEMU_BLD_DIR"]
if not os.path.isdir(qiBldPath):
  raise ValueError("ERROR: missing $KAENA_PATH/../qemu_inkling path  at %s" % qiBldPath)

krtBldPath = os.environ["KRT_BLD_DIR"]
if not os.path.isdir(krtBldPath):
  raise ValueError("ERROR: missing kaena runtime build")

qiPath = os.path.join(qiBldPath, "x86_64-softmmu", "qemu-system-x86_64")

krtVmPath = '/home/kaena/'

# File paths / url and sha256sum
vdis = {
  "lubuntu1" : [
    "s3://kaena-vdi/lubuntu_20180525.img",
    "eefa63e6cfa626f3f6ad0622f046b906637b0c4146854f707660da9ab7a71d55" ],
  "debian1" : [
    "s3://kaena-vdi/debian-9.4.0.qcow",
    "bf477b909bcca20c42e0c5026c5fad050a7aa926b5d567608486f842c8ad9ae6" ],
  "debian1-4G" : [
    "s3://kaena-vdi/debian-9.4.0-4G.qcow",
    "4243469768faf66e46298a240816f46152eeaed375d350d94b33d6e3c88475ce" ],
  "ubuntu-18.04": [
    "s3://kaena-vdi/ubuntu-18.04-compressed.qcow2",
    "7ec65012ea281be9f364575b8b371ba407b371f87c446d6bafeebf06aa8ebb8a" ],
  }

defaultVdi, checksumVdi = vdis["ubuntu-18.04"]

def portInUse(port):
  inUse = True
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    try:
      s.bind(("localhost", port))
      inUse = False
    except socket.error as e:
      if e.errno == errno.EADDRINUSE:
        print("INFO portInUse: Port %d is already in use" % port, flush=True)
      else:
        print("INFO portInUse: ", e, flush=True)
  return inUse

def sha256checksum(fileName):
  # Use unix instead of hashlib to ensure 100% match with the os cmd line
  cmd = "sha256sum %s" % fileName
  checksum = ""
  with os.popen(cmd) as f:
    checksum = f.read().split(" ")[0]
  return checksum

parser = argparse.ArgumentParser(epilog=epilog,
           formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument('--action', help='Default is inference, others are: start_pool', default="inference")
parser.add_argument('--vdi', help='Path to virtual disk image for the qemu VM. It can be file or S3 URL including options, the default is ' + defaultVdi, default=defaultVdi)
parser.add_argument('--port', help='SSH port for the qemu VM', type=int, default=5555)
parser.add_argument('--pool', help='Port range that defines Qemu process pool', type=int, nargs='+', default=[])
parser.add_argument('--mem', help='Memory for the qemu VM, default 512MB', type=int, default=512)
parser.add_argument('--kelf', help='Kelf directory to compile', default=None)
parser.add_argument('--sg', help='Subgraph label for identifying which SG executes', default=None)
parser.add_argument('--ifmaps', help='List of input images in sim ifmap format', nargs='+', default=None)
args = parser.parse_args()

class Qemu:
  def __init__(self, vdi, mem, port):
    #qemuOpts = '-monitor stdio'
    qemuOpts = '-nographic'
    self.vdi = vdi
    self.localVdi = "copy.vdi"
    
    # Create on the fly to avoid issues with git chmod
    self.pemText = '''
-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEA2T87/SGMJkXPqDtZ2paK315Nh6aEZciDj4YiTwOJ70Ti0yiG
ej1iDrtnBy40TFWzvcwIkus3a/cTlOuflk2yE1kaVbnMMUMIGBV/K82nG9m4/c+G
0rdnz3PwAtCnuDkeGGP7ew6FVp8XQ4GSdCt8qgdHuhIKAiVgb0xNXwXo1++mgQBU
hPCHKhNHCRdw7Z3GgRTdtddUe3xPZNaBA0qk2HKe/LtqJGik490/yhNW+QIBnXye
XFoT32hPbTkU3GymmNCrSET+HxmwdeUqpspRrZnDZeJ7JV/H4cDpBkWjQFY5D1PX
g8G8ia+szTZyDauA5gZJM/Z7PD66vOm8lY0UzwIDAQABAoIBAFwkwvfxg7U0BQjQ
66KYGZz2LaIskZluO8bjWKf000tmB2MSnD86y919xQw5n7sE2rDU2ooeNCqZ6HdQ
nSauG6qzL0VPAfme+c7lR0Q3/PoGFb2piQDVA7Xs8c7v20N7DnW/6oleNlXwMnjS
e2DElSK05cpZHl+cpNNwJJz6L7FuTvvcltfn9DluDkqODTr/dfJ8JXXedudBCYP5
GL/74rnUsxhk7aozrIZy3Q4sCUyvgyjRU9mMLqIWmK2SPrrYsMGU5QTalVlHpSnG
GtkmVD+eGCPL07kN5ZuEQ7CAgfHq3ViUC3F+3qmR4vEmNs4Bt8rbKsqvvunNgjcm
iYx/kmECgYEA+CsDqsAJpQmX1pMSgniDcPUsMoVLF06eTyLUAYYY5LnWDnP8losi
7lL6+OcULorF1eXw+FqK4IhNpIk3MZC2uVCT2WkK/B8WAOQtB+OHb1kV8wkEQPbY
UUQfvkp9E/D3ByV6CRpuMhE6jrBUR37HXqEr7+HWSJ1koj3lD9nR6V8CgYEA4Bpn
lJd2pPZTv5Wh/DdWNNpT9hwcwi7r5oRQPTAtdiHNq8Z+6USMwjvBd7KI6UOrfSxP
VBatl8ve9FhYFlNQXeUeGaUZXfWd5Z3dQ2Y5VtnP13SHJT162Wmt4i6nPpVwwVvJ
6QgPggfM3xdNDbiF5x6T/Zgh5V/Tmky+xGkz2pECgYEAnZ/kkl2rQpIXSQjdJtWY
1vRCgEw9Z65dyvHaKqWbxhtrJH7zHkN9ilZWZiWPoggupC+KoJQRxY+NkUY+MlMy
W/4cCmk3uu+bsDE9kNcpvMWetWEyvHiM6QEWEG2LiFDy9i0NmB6bg12CDgNdZJPX
2fkQySpuSmz98DbT+P9m3o0CgYBwWcyEGktI+JWT/xhuse9uH+boA8AHOi7aKotv
oa+pAdlyvNjzaYKH/h1IPSGWkG5xGr3KknQFHhhwt7mxt6Ma77rfcH3/NRwr+bDs
EVu9xwUEJ095xBDK3shmFK2UGqekyLe5NGlR70cusSfYMSIwdIwNHzAfJqOXP9KD
9ZohgQKBgQCVgkGXKhncre6t8JYgjLplwAnuMWTatMQK+qtCaR29KSy6LeXW71Je
1J2fk91Z6+o0d31eTI5mOH9RBvJMGLpOkWw5769vDGNiIn3PiVK4ezdd2Zwz2T3U
c7unPf36AHohqWJgqn6L9z2PZRDplEs/82uzKzEvmFhMFWyyBZKtGg==
-----END RSA PRIVATE KEY-----
'''
    self.pemFile = "%s/.ssh/qemu_rt.pem" % os.getenv('HOME')
    if not os.path.isfile(self.pemFile):
      with open(self.pemFile, 'w') as fhPem:
        fhPem.write(self.pemText)
      os.chmod(self.pemFile, stat.S_IREAD)
    
    qemuNoInkling = os.getenv("QEMU_NO_INKLING", None)
    if qemuNoInkling == None:
      self.cmd = '%s %s -m %d -device pci-inkling %s -net nic,model=virtio,netdev=net0 -netdev user,id=net0,hostfwd=tcp::%d-:22 -serial file:log-qemu_serial.txt' % (qiPath, self.localVdi, mem, qemuOpts, port)
    else:
      self.cmd = '%s %s -m %d                     %s -net nic,model=virtio,netdev=net0 -netdev user,id=net0,hostfwd=tcp::%d-:22 -serial file:log-qemu_serial.txt' % ("/usr/bin/qemu-system-x86_64", self.localVdi, mem, qemuOpts, port)
    if os.path.exists("/dev/kvm"):
        self.cmd += "  --enable-kvm "
    self.port = port
    self.cmdForSsh = 'ssh -n -o StrictHostKeyChecking=no -o ConnectTimeout=600 -o UserKnownHostsFile=/dev/null -p %d -i %s kaena@localhost' % (self.port, self.pemFile)
    self.cmdForRsync = 'rsync -av --progress -e "ssh -o StrictHostKeyChecking=no -o ConnectTimeout=600 -o UserKnownHostsFile=/dev/null -p %s -i %s"' % (self.port, self.pemFile)

  def start(self, restartId):
    self.restartId = restartId
    if os.path.isfile(self.vdi):
      cmd = "/bin/cp %s %s" % (self.vdi, self.localVdi)
      print('INFO: copying vdi  "%s"' % cmd, flush=True)
      os.system(cmd)
    elif self.vdi[0:5].upper() == 'S3://':
      cmd = "aws s3 cp --quiet %s %s %s" % (self.vdi, self.localVdi, "--profile kaena")
      print('INFO: copying vdi from S3 by  "%s"' % cmd, flush=True)
      os.system(cmd)
      checksum = sha256checksum(self.localVdi)
      if checksum == checksumVdi:
        print("INFO: verified vdi checksum for %s" % self.localVdi, flush=True)
      else:
        raise ValueError("ERROR: vdi checksum incorrect for %s  expected %s  got %s" % (self.localVdi, checksumVdi, checksum))
    else:
      raise ValueError('ERROR: unknown vdi specification "%s"' % vdi)
    assert os.path.isfile(self.localVdi)
    cmd = 'sh -c "%s 2>&1 | tee log-qemu.txt"' % self.cmd
    print("INFO: starting Qemu  %s" % cmd, flush=True)
    self.fh = pexpect.spawn(cmd, maxread=200000, searchwindowsize=200000)
    self.fh.expect("QEMU")
    self.fh.send("\r")
    time.sleep(30)  # ssh to the qemu guest is getting random errors, maybe this can help

  def testGuest(self, numAttempts):
    # Make sure the qemu quest is functional
    phaseId = self.restartId
    for attempId in range(numAttempts):
      print("\nINFO: testGuest  phase %d  attempt %d" % (phaseId, attempId), flush=True)
      testFile = "test_qemu_guest-%02d-%02d.txt" % (phaseId, attempId)
      testFileVm = "/tmp/" + testFile
      testFileReturned = testFile.replace(".txt", "-ret.txt")
      with open(testFile, 'w') as f:
        f.write("Test attempt %02d" % attempId)
      self.rsyncToVm(testFile, testFileVm)
      self.rsyncFromVm(testFileVm, testFileReturned)
      if os.path.isfile(testFileReturned):
        print("INFO: testGuest PASSED after attempt %d\n" % attempId, flush=True)
        return True
      print("INFO: testGuest diagnosing ssh connection %d" % attempId, flush=True)
      self.sshCmd("/bin/true", "-vvv")  # Baseline diagnostics
      time.sleep(30)  # on c5 the ssh returns immediately so allow wait beween attempts
    return False
  
  def stop(self):
    self.rsyncFromVm("/var/log/syslog", ".")
    checksum = sha256checksum(self.localVdi)
    
    # Remove vdi to reduce disk space (after printing its checksum for later forensics)
    print("INFO: Qemu.stop: removing vdi file %s %s" % (self.localVdi, checksum), flush=True)
    try:
      os.remove(self.localVdi)
    except OSError:
      pass
        
    # Store previous attemp qemu logs
    cmd = "tar cvzf logs-qemu-restart-%02d.tgz log-qemu*.txt" % self.restartId
    print("INFO: Qemu.stop:  %s" % cmd)
    os.system(cmd)
    
    # Clean up Qemu process
    try:
      self.fh.expect("Something non-existing to flush logs...", timeout=5)
    except:
      pass    
    print("INFO: stopping QEMU")
    try:
      self.fh.close()
    except:
      pass

    # Various reports
    print("INFO: checking for zero-size files:", flush=True)
    os.system("find -size 0")

  def rsyncToVm(self, fromDir, toVmDir, opts=None):
    cmd = '%s %s kaena@localhost:%s' % (self.cmdForRsync, fromDir, toVmDir)
    if opts != None:
      cmd = cmd.replace("rsync ", "rsync %s " % opts)
    print("INFO: rsyncToVm executing %s" % cmd, flush=True)
    return os.system(cmd) == 0
  def rsyncFromVm(self, fromVmDir, toDir):
    cmd = '%s kaena@localhost:%s %s' % (self.cmdForRsync, fromVmDir, toDir)
    print("INFO: rsyncFromVm executing %s" % cmd, flush=True)
    return os.system(cmd) == 0
  def sshCmd(self, cmd, opt=""):
    fullCmd = "%s %s '%s'" % (self.cmdForSsh, opt, cmd)
    print("INFO: sshCmd executing %s" % fullCmd, flush=True)
    return os.system(fullCmd)
  def lock(self):
    return self.sshCmd('l=/var/lock/qemu; test -f $l || echo $$ > $l; expr $$ == `cat $l`') == 0
  def unlock(self):
    return self.sshCmd('l=/var/lock/qemu; /bin/rm -f $l') == 0
    
class Krt:
  def __init__(self, qemu, timeout):
    self.qemu = qemu
    self.cwd = os.getcwd()
    self.inklingTimeout = timeout
    self.kelfVmDir = "/tmp/reg-1"  # non-sg spefic, for --action cleanup_pool
    self.sg = "sg00"

  def install(self):
    runtimSrcPath = os.environ["KAENA_RT_PATH"]
    if not os.path.isdir(runtimSrcPath):
      raise ValueError("ERROR: missing runtime src at %s" % runtimSrcPath)
    krtPackages = glob.glob(os.path.join(krtBldPath, "krt-*.*-uio-core.tar.gz"))
    if len(krtPackages) != 1:
      raise ValueError("ERROR: Found {} runtime packages at {}".format(len(krtPackages), krtBldPath))
    self.qemu.rsyncToVm(krtPackages[0], krtVmPath + "/")
    self.qemu.rsyncToVm(os.path.join(runtimSrcPath, "kbinlib", "vfio_bind.py"), krtVmPath + "/")
    self.qemu.sshCmd("sudo tar xfz {} -C /usr/".format(krtVmPath + "/krt-*.*-uio-core.tar.gz"))
    self.qemu.sshCmd("sudo modprobe vfio enable_unsafe_noiommu_mode=Y")
    self.qemu.sshCmd("sudo {}/vfio_bind.py".format(krtVmPath))

  def addModel(self, kelfDir, kelfVmDir, sg):
    self.kelfVmDir = kelfVmDir
    self.sg = sg
    self.qemu.sshCmd("mkdir -p %s" % kelfVmDir)
    self.qemu.rsyncToVm(kelfDir + "/", kelfVmDir, "--copy-links")
    cmdCompile = 'cd %s; kelf2kbin def.json' % (kelfVmDir)
    self.qemu.sshCmd(cmdCompile)
  def start(self):
    self.ifmapDir = "%s/ifmap" % self.kelfVmDir
    self.ofmapDir = "%s/ofmap" % self.kelfVmDir
    self.qemu.sshCmd("mkdir %s %s" % (self.ifmapDir, self.ofmapDir))
    cmdRuntime = 'cd %s; sudo kbin_rt %s %s %s 0000:00:04.0 -n 1 -t %d > log-krt.txt 2>&1 &' % (self.kelfVmDir,
                   self.kelfVmDir, self.ifmapDir, self.ofmapDir, self.inklingTimeout)
    self.qemu.sshCmd(cmdRuntime)
  def stop(self):
    self.qemu.rsyncFromVm(self.kelfVmDir + "/log-krt_%s.txt" % self.sg, ".")
    debug = True
    if debug:
      self.qemu.rsyncFromVm(self.kelfVmDir + "/", "debug_kelf_%s" % self.sg)
    self.qemu.sshCmd("/bin/rm -rf %s" % self.kelfVmDir)
  def inference(self, ifmap, ofmap):
    ifmapPath = os.path.realpath(ifmap)
    if self.qemu.rsyncToVm(ifmapPath, self.ifmapDir, "--copy-links"):
      self.qemu.sshCmd('pidofp=$(pidof kbin_rt); count=0; until [ -f %s/out.bin -o $count -gt %d ] || [ -z $pidofp ]; do sleep 1 ; pidofp=$(pidof kbin_rt); let count++; echo $count; done' % (self.ofmapDir, self.inklingTimeout))

      if self.qemu.rsyncFromVm(self.ofmapDir + "/out.bin", ofmap):
        print("INFO: the qemu, guest os and krt sucessfully created the output fmap binary")
      else:
        print("ERROR: failed to transfer ofmap from the qemu guest os")
    else:
      print("ERROR: failed to transfer ifmap %s to the qemu guest os" % ifmapPath)


class QemuPool:
  def __init__(self, ports, vdi, mem, inklingTimeout):
    if len(ports) == 2:
      self.ports = range(ports[0], ports[1])
    else:
      self.ports = ports
    self.qemus = []
    for port in self.ports:
      qemu = Qemu(vdi, mem, port)
      krt = Krt(qemu, inklingTimeout)
      self.qemus.append((qemu, krt))
  def checkPorts(self):
    for port in self.ports:
      if portInUse(port):
        return False
    return True
  def startPool(self):
    if self.checkPorts():
      for idx in range(len(self.ports)):
        port = self.ports[idx]
        qemu, krt = self.qemus[idx]
        d = "pool_%d" % port
        os.mkdir(d)
        os.chdir(d)
        for qemuRestartId in range(3):
          qemu.start(qemuRestartId)
          if qemu.testGuest(4):
            krt.install()
            break
          else:
            qemu.stop()
        os.chdir("..")
    else:
      raise ValueError("ERROR: cannot start qemu pool - the ports are in use")
    return len(self.qemus) == len(self.ports)
  def getAvailQemu(self):
    found = False
    while not found:
      idx = random.randint(0, len(self.qemus)-1)
      print("INFO: trying to lock QEMU %d on port %d ..." % (idx, self.ports[idx]), flush=True)
      qemu, krt = self.qemus[idx]
      found = qemu.lock()
      time.sleep(1)
    print("INFO: locked QEMU %d on port %d" % (idx, self.ports[idx]), flush=True)
    return qemu, krt
  def cleanup(self):
    for idx in range(len(self.ports)):
      port = self.ports[idx]
      qemu, krt = self.qemus[idx]
      krt.stop()
      qemu.unlock()

inklingTimeout = 6000


if len(args.pool) > 0:
  qp = QemuPool(args.pool, args.vdi, args.mem, inklingTimeout)
  if args.action == 'start_pool':
    if not qp.startPool():
      raise RuntimeError('ERROR: failed to start qemus, %d requested while %d started' % (len(qp.ports), len(qp.qemus)))
    print('INFO: your qemu pool has started. You can access it on ports %s. To stop them terminate this process' % qp.ports, flush=True)
    i = 0
    while True:
      time.sleep(10)
      print('INFO: holding quemus %d. Sleep 10. Use  export KAENA_QEMU_RT_POOL="%s"; RunAll --force_qemu --test ... to run.   Terminate this process to close the qemus' % (i, " ".join(str(p) for p in qp.ports)), flush=True)
      i += 1
  elif args.action == 'cleanup_pool':
    qp.cleanup()
  elif args.action == 'inference':
    if args.kelf == None:
      raise ValueError("ERROR: use --kelf")
    qemu, krt = qp.getAvailQemu()
    krt.addModel(args.kelf, "/tmp/reg-1/%s" % args.sg, args.sg)
    krt.start()
    assert len(args.ifmaps) == 1
    for ifmap in args.ifmaps:
      krt.inference(ifmap, "out-%s.bin" % args.sg)
    krt.stop()
    qemu.unlock()
    
else:
  # port mode
  if args.kelf == None:
    raise ValueError("ERROR: use --kelf")
  qemuOk = False
  port = args.port
  for qemuRestartId in range(3):
    while portInUse(port):
      port += 3
    print("INFO: using available port %d  (--port was %d)" % (port, args.port))
    qemu = Qemu(args.vdi, args.mem, args.port)
    qemu.start(qemuRestartId)
    if qemu.testGuest(4):
      qemuOk = True
      krt = Krt(qemu, inklingTimeout)
      krt.install()
      krt.addModel(args.kelf, "/tmp/reg-1/%s" % args.sg, args.sg)
      krt.start()
      for ifmap in args.ifmaps:
        krt.inference(ifmap, "out-%s.bin" % args.sg)
      krt.stop()
    else:
      print("ERROR: Failed to start Qemu  phase %d, restarting ..." % qemuRestartId)
    qemu.stop()
    if qemuOk:
      break
    else:
      time.sleep(30)  # qemu was still failing upon several restarts. Delay after stop() may help.
  if not qemuOk:
      raise ValueError("ERROR: Failed to start QEMU")

