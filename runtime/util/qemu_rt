#!/usr/bin/env python3

# Copyright (C) 2018, Amazon.com. All Rights Reserved


# Kaena qemu Inkling and emulator runtime wrapper

epilog = '''
The command is automatically invoked from RunAll through the nn_executor

The disk image is added to S3 by e.g,
  aws s3 cp /work1/zejdaj/git_repo/qemu_inkling/my_vm.img s3://kaena-vdi/lubuntu_20180525 --profile kaena
and in future we'll use the  kaena-compiler/runtime/util/vdi/vdi_manager.py to create and populate VDIs

There are 2 basic use modes:
 - Single port (--port) which starts qemu, boots its os, loads drivers, starts runtime and performs 1 inference
 - Pool (--pool) whih decouples starting qemu (boot os, add drivers) and the inference

The pool flow is https://issues.amazon.com/issues/kaena-574 . In Summary:

# Start a qemu pool (with 5 qemus, 0 to 4)
  $KAENA_PATH/runtime/util/qemu_rt --pool 7100 7105 --action start_pool > log_pool 2>&1 &
    # The pool ports can be 1 number (eg 5555, ie 1 qemu), 2 for range (8000 8010 means 10 qemus on ports 8000 to 8009), 3+ for a list of individual ports (e.g., 8003 8009 19765).

# Watch till pool completes initialization. It then prints env instructions:
  tail -f log_pool
   # prints 
      INFO: holding quemus <i>. Sleep 10. Use  export KAENA_QEMU_RT_POOL="7100 7105"; RunAll --force_qemu --test ... to run.   Terminate this process to close the qemus

# Use the above command to run regression tests. On small pools running slow tests also use --parallel <num ports ie 5> to make sure timeouts are properly applied
   ( export KAENA_QEMU_RT_POOL="7100 7105"; $KAENA_PATH/test/e2e/RunAll --force_qemu --parallel 5 --level 10 ) > log 2>1 &
     # Multiple runs or users can share the same pool - just remember that the time in the qemu_rt backend is part of the overall job timeout

# To terminate the pool (days later) simply kill the first process and remove pool_* directories where you started the pools

Zebu pool is similar:
  # Start
    $KAENA_PATH/runtime/util/qemu_rt --zebu "pool zebuserver2--6 zebuserver3--6" --action start_pool > log_pool 2>&1 &
  # Follow the instructions printed in the log_pool, which for teh above is
    ( setenv KAENA_ZEBU_SERVER "pool zebuserver2--6 zebuserver3--6"; $KAENA_PATH/test/e2e/RunAll --force_qemu --parallel 2 --test 0-1conv0_wave )
  # Stop the pool process
    $KAENA_PATH/runtime/util/qemu_rt --zebu "pool zebuserver2--6 zebuserver3--6" --action cleanup_pool
  # Notes
    - Starting the pool is sequential (ie, starting 2 takes 2x longer than 1)
    - Pools can mix and match - ie, you start a pool of 2, one crashes, then start new pool of 1 on
      the crashed host, but pass full list to RunAll as before
    - Just like qemu, the pools are multi-user, ie your pool can be used by you (

'''

import argparse
import os, sys, stat, time, random, datetime, re, tempfile, shutil
import glob
import pexpect
import socket, errno
import xml.etree.ElementTree as ET
import subprocess
import getpass
import signal

print("\nINFO %s : started as  " % str(datetime.datetime.now()), " ".join(["'"+word+"'" if " " in word else word for word in sys.argv]), flush=True)
qiBldPath = os.environ["QEMU_BLD_DIR"]
if not os.path.isdir(qiBldPath):
  raise ValueError("ERROR: missing $KAENA_PATH/../qemu_inkling path  at %s" % qiBldPath)


qiPath = os.path.join(qiBldPath, "x86_64-softmmu", "qemu-system-x86_64")

# File paths / url and sha256sum
vdis = {
  "lubuntu1" : [
    "s3://kaena-vdi/lubuntu_20180525.img",
    "eefa63e6cfa626f3f6ad0622f046b906637b0c4146854f707660da9ab7a71d55" ],
  "debian1" : [
    "s3://kaena-vdi/debian-9.4.0.qcow",
    "bf477b909bcca20c42e0c5026c5fad050a7aa926b5d567608486f842c8ad9ae6" ],
  "debian1-4G" : [
    "s3://kaena-vdi/debian-9.4.0-4G.qcow",
    "4243469768faf66e46298a240816f46152eeaed375d350d94b33d6e3c88475ce" ],
  "ubuntu-18.04": [
    "s3://kaena-vdi/ubuntu-18.04-compressed.qcow2",
    "7ec65012ea281be9f364575b8b371ba407b371f87c446d6bafeebf06aa8ebb8a" ],
  "ubuntu-18.04-fixed_sshd": [
    "s3://kaena-vdi/ubuntu-18.04-fixed_sshd.qcow2",
    "53c8ecc732d7bc2304e7cb2c56b9df2af07967cfa7c790ed756c1c55da24352f" ],
  "ubuntu-18.04-24G": [
    "s3://kaena-vdi/ubuntu-18.04-24G.qcow2",
    "38b7c79049c260ca497d8dc67617f7d6aa5a3cc6e62c8c1545217cfeb96859b4" ],
  "ubuntu-18.04-24G_pytest": [
    "s3://kaena-vdi/ubuntu-18.04-24G_pytest.qcow2",
    "3ff185ea2110ec4f9943c594cadab3ea265414ee971497fc3762d3ceeacdb70e" ],
  }

defaultVdi, checksumVdi = vdis["ubuntu-18.04-24G_pytest"]
defaultGrpcPort = 5556

zebuGrpcHost = {
  'zebuserver1': 20000,
  'zebuserver2': 20001,
  'zebuserver3': 20002,
  'zebuserver4': 20003
  }
poolPidFileName = 'poolpid.txt'

# Using env variable to pass on the number of inference
# request for each input. When nn_executor calls qemu_rt
# for a sub-graph, the inference will be run using the 
# input provided in the subgraph multiple times
numInferences = 1
envNumInferences = os.getenv("QEMU_KRT_NUM_INFERENCES", None)
if envNumInferences != None:
  numInferences = int(envNumInferences)

def portInUse(port):
  inUse = True
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    try:
      s.bind(("localhost", port))
      inUse = False
    except socket.error as e:
      if e.errno == errno.EADDRINUSE:
        print("INFO portInUse: Port %d is already in use" % port, flush=True)
      else:
        print("INFO portInUse: ", e, flush=True)
  return inUse

def sha256checksum(fileName):
  # Use unix instead of hashlib to ensure 100% match with the os cmd line
  cmd = "sha256sum %s" % fileName
  checksum = ""
  with os.popen(cmd) as f:
    checksum = f.read().split(" ")[0]
  return checksum

def getPortsToUse(port=None, grpcPort=None):
  hashStr = '%s-%s' % (getpass.getuser(), os.getcwd())
  # Randomize SSH port
  if port is None: 
      port = 5555
  port += abs(hash(hashStr)) % 8000
  while portInUse(port) and port < 60000:
    port += int(random.random()*100)
  # Randomize GRPC port  
  if grpcPort is None: 
      grpcPort = 5556
  grpcPort += abs(hash(hashStr)) % 8000
  while portInUse(grpcPort) and grpcPort < 60000:
    grpcPort += int(random.random()*100)
  return port, grpcPort

parser = argparse.ArgumentParser(epilog=epilog,
           formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument('--action', help='Default is inference, others are: start_pool', default="inference")
parser.add_argument('--vdi', help='Path to virtual disk image for the qemu VM. It can be file or S3 URL including options, the default is ' + defaultVdi, default=defaultVdi)
parser.add_argument('--port', help='SSH port for the qemu VM', type=int, default=5555)
parser.add_argument('--grpcHost', help='GRPC host to use for talking to krtd', default="localhost")
parser.add_argument('--grpcPort', help='GRPC port to use for talking to krtd', type=int, default=defaultGrpcPort)
parser.add_argument('--pool', help='Port range that defines Qemu process pool', type=int, nargs='+', default=[])
parser.add_argument('--mem', help='Memory for the qemu VM, default 1024MB', type=int, default=1024)
parser.add_argument('--kelf', help='Kelf directory to compile', default=None)
parser.add_argument('--sg', help='Subgraph label for identifying which SG executes', default=None)
parser.add_argument('--ifmaps', help='List of input images in sim ifmap format', nargs='+', default=None)
parser.add_argument('--zebu', help='Zebu host to use emulator model of Tonga instead of starting Qemu with SW Tonga locally', default=None)
parser.add_argument('--pytest', action="store_true", help='Run non-compiler pytest')
args = parser.parse_args()

QemuVdiCacheFile = "/tmp/ubuntu-18.04-24G_pytest.qcow2"
krtBldPath = os.environ["KRT_BLD_DIR"]
kelfVmDirGlobal = "/tmp/reg-1"
if args.zebu:
  krtBldPath = os.environ["KRT_EMU_BLD_DIR"]
  #kelfVmDirGlobal = "/media/sf_SharedFolder/reg-1"
if not os.path.isdir(krtBldPath):
  raise ValueError("ERROR: missing kaena runtime build")
print("INFO: using runtime build  %s" % krtBldPath)
krtVmPath = '/tmp/krt-1'


# Common class for backend platforms like Qemu or Zebu

class BePlat(object):
  def __init__(self, port=None,grpcHost=None,grpcPort=None):
    self.sshHost = None
    self.sshUser = None
    self.sshCommand = None
    self.tongaDevice = "0000:00:04.0"
    # Create on the fly to avoid issues with git chmod
    self.pemText = '''
-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEA2T87/SGMJkXPqDtZ2paK315Nh6aEZciDj4YiTwOJ70Ti0yiG
ej1iDrtnBy40TFWzvcwIkus3a/cTlOuflk2yE1kaVbnMMUMIGBV/K82nG9m4/c+G
0rdnz3PwAtCnuDkeGGP7ew6FVp8XQ4GSdCt8qgdHuhIKAiVgb0xNXwXo1++mgQBU
hPCHKhNHCRdw7Z3GgRTdtddUe3xPZNaBA0qk2HKe/LtqJGik490/yhNW+QIBnXye
XFoT32hPbTkU3GymmNCrSET+HxmwdeUqpspRrZnDZeJ7JV/H4cDpBkWjQFY5D1PX
g8G8ia+szTZyDauA5gZJM/Z7PD66vOm8lY0UzwIDAQABAoIBAFwkwvfxg7U0BQjQ
66KYGZz2LaIskZluO8bjWKf000tmB2MSnD86y919xQw5n7sE2rDU2ooeNCqZ6HdQ
nSauG6qzL0VPAfme+c7lR0Q3/PoGFb2piQDVA7Xs8c7v20N7DnW/6oleNlXwMnjS
e2DElSK05cpZHl+cpNNwJJz6L7FuTvvcltfn9DluDkqODTr/dfJ8JXXedudBCYP5
GL/74rnUsxhk7aozrIZy3Q4sCUyvgyjRU9mMLqIWmK2SPrrYsMGU5QTalVlHpSnG
GtkmVD+eGCPL07kN5ZuEQ7CAgfHq3ViUC3F+3qmR4vEmNs4Bt8rbKsqvvunNgjcm
iYx/kmECgYEA+CsDqsAJpQmX1pMSgniDcPUsMoVLF06eTyLUAYYY5LnWDnP8losi
7lL6+OcULorF1eXw+FqK4IhNpIk3MZC2uVCT2WkK/B8WAOQtB+OHb1kV8wkEQPbY
UUQfvkp9E/D3ByV6CRpuMhE6jrBUR37HXqEr7+HWSJ1koj3lD9nR6V8CgYEA4Bpn
lJd2pPZTv5Wh/DdWNNpT9hwcwi7r5oRQPTAtdiHNq8Z+6USMwjvBd7KI6UOrfSxP
VBatl8ve9FhYFlNQXeUeGaUZXfWd5Z3dQ2Y5VtnP13SHJT162Wmt4i6nPpVwwVvJ
6QgPggfM3xdNDbiF5x6T/Zgh5V/Tmky+xGkz2pECgYEAnZ/kkl2rQpIXSQjdJtWY
1vRCgEw9Z65dyvHaKqWbxhtrJH7zHkN9ilZWZiWPoggupC+KoJQRxY+NkUY+MlMy
W/4cCmk3uu+bsDE9kNcpvMWetWEyvHiM6QEWEG2LiFDy9i0NmB6bg12CDgNdZJPX
2fkQySpuSmz98DbT+P9m3o0CgYBwWcyEGktI+JWT/xhuse9uH+boA8AHOi7aKotv
oa+pAdlyvNjzaYKH/h1IPSGWkG5xGr3KknQFHhhwt7mxt6Ma77rfcH3/NRwr+bDs
EVu9xwUEJ095xBDK3shmFK2UGqekyLe5NGlR70cusSfYMSIwdIwNHzAfJqOXP9KD
9ZohgQKBgQCVgkGXKhncre6t8JYgjLplwAnuMWTatMQK+qtCaR29KSy6LeXW71Je
1J2fk91Z6+o0d31eTI5mOH9RBvJMGLpOkWw5769vDGNiIn3PiVK4ezdd2Zwz2T3U
c7unPf36AHohqWJgqn6L9z2PZRDplEs/82uzKzEvmFhMFWyyBZKtGg==
-----END RSA PRIVATE KEY-----
'''
    self.pemFile = "%s/.ssh/qemu_rt.pem" % os.getenv('HOME')
    if not os.path.isfile(self.pemFile):
      with open(self.pemFile, 'w') as fhPem:
        fhPem.write(self.pemText)
      os.chmod(self.pemFile, stat.S_IREAD)
    
    # Log all shell commands to a file
    self.cmdFh = open('replay-qemu_rt.txt', 'w')
    newPort, newgrpcPort = getPortsToUse(port, grpcPort)
    if port != None:
      print("INFO: using available port %d  (--port was %d)" % (newPort, port))
    if grpcPort != None:
      print("INFO: using available port %d for grpc  (--grpcPort was %d)" % (newgrpcPort, grpcPort))
    self.port = newPort
    self.grpcHost = grpcHost
    self.grpcPort = newgrpcPort


  def __del__(self):
    self.cmdFh.close()
  def logReplay(self, cmd):
    self.cmdFh.write("# " + str(datetime.datetime.now()) + '\n')
    self.cmdFh.write(cmd + '\n\n')
    self.cmdFh.flush()
  def osSystem(self, cmd):
    self.logReplay(cmd)
    return os.system(cmd)
  def sshCmd(self, cmd, opt=""):
    fullCmd = "%s %s %s@%s '%s'" % (self.sshCommand, opt, self.sshUser, self.sshHost, cmd)
    print("INFO %s : sshCmd executing %s" % (str(datetime.datetime.now()),fullCmd), flush=True)
    return self.osSystem(fullCmd)
  def rsyncToVm(self, fromDir, toVmDir, opts=None):
    cmd = '%s "%s" %s@%s:%s' % (self.cmdForRsync, fromDir, self.sshUser, self.sshHost, toVmDir)
    if opts != None:
      cmd = cmd.replace("rsync ", "rsync %s " % opts)
    print("INFO %s : rsyncToVm executing %s" % (str(datetime.datetime.now()), cmd), flush=True)
    return self.osSystem(cmd) == 0
  def rsyncFromVm(self, fromVmDir, toDir):
    cmd = '%s "%s@%s:%s" %s' % (self.cmdForRsync, self.sshUser, self.sshHost, fromVmDir, toDir)
    print("INFO %s : rsyncFromVm executing %s" % (str(datetime.datetime.now()), cmd), flush=True)
    return self.osSystem(cmd) == 0
  def lock(self):
    return self.sshCmd('l=/var/lock/qemu; test -f $l || echo $$ > $l; expr $$ == `cat $l`') == 0
  def unlock(self):
    return self.sshCmd('l=/var/lock/qemu; /bin/rm -f $l') == 0
  def getTongaDevice(self):
    return self.tongaDevice

class Qemu(BePlat):
  def __init__(self, vdi, mem, port, grpcHost="localhost", grpcPort=defaultGrpcPort):
    BePlat.__init__(self, port, grpcHost=grpcHost, grpcPort=grpcPort)
    
    #qemuOpts = '-monitor stdio'
    qemuOpts = '-nographic'
    self.vdi = vdi
    self.localVdi = "copy.vdi"
    self.type = "qemu"
    qemuNoInkling = os.getenv("QEMU_NO_INKLING", None)
    assert not portInUse(self.grpcPort) and not portInUse(self.port)
    if qemuNoInkling == None:
        self.cmd = '%s %s -m %d -device pci-inkling %s -net nic,model=virtio,netdev=net0 -netdev user,id=net0,hostfwd=tcp::%d-:22,hostfwd=tcp::%d-:%d -serial file:log-qemu_serial.txt' % (qiPath, self.localVdi, mem, qemuOpts, self.port, self.grpcPort, self.grpcPort)
    else:
        self.cmd = '%s %s -m %d                     %s -net nic,model=virtio,netdev=net0 -netdev user,id=net0,hostfwd=tcp::%d-:22,hostfwd=tcp::%d-:%d -serial file:log-qemu_serial.txt' % ("/usr/bin/qemu-system-x86_64", self.localVdi, mem, qemuOpts, self.port, self.grpcPort, self.grpcPort)
    if os.path.exists("/dev/kvm"):
        self.cmd += "  --enable-kvm "
    self.sshUser = "kaena"
    self.sshHost = "localhost"
    sshOpt = "-o StrictHostKeyChecking=no -o ConnectTimeout=600 -o UserKnownHostsFile=/dev/null"
    self.sshCommand = 'ssh -n %s -p %d -i %s ' % (sshOpt, self.port, self.pemFile)
    self.cmdForRsync = 'rsync -av --progress -e "ssh %s -p %s -i %s"' % (sshOpt, self.port, self.pemFile)

  def start(self, restartId):
    self.restartId = restartId
    if os.path.isfile(self.vdi):
      cmd = "/bin/cp %s %s" % (self.vdi, self.localVdi)
      print('INFO: copying vdi  "%s"' % cmd, flush=True)
      self.osSystem(cmd)
    elif (os.path.isfile(QemuVdiCacheFile) and (sha256checksum(QemuVdiCacheFile) == checksumVdi)):
      cmd = "/bin/cp %s %s" % (QemuVdiCacheFile, self.localVdi)
      print('INFO: copying vdi from cache  "%s"' % cmd, flush=True)
      self.osSystem(cmd)
    elif self.vdi[0:5].upper() == 'S3://':
      if not (os.path.isfile(QemuVdiCacheFile)):
        copyLocation = QemuVdiCacheFile
      else:
        copyLocation = self.localVdi
      cmd = "aws s3 cp --quiet %s %s %s" % (self.vdi, copyLocation, "--profile kaena")
      print('INFO: copying vdi from S3 by  "%s"' % cmd, flush=True)
      self.osSystem(cmd)
      checksum = sha256checksum(copyLocation)
      if checksum == checksumVdi:
        print("INFO: verified vdi checksum for %s" % copyLocation, flush=True)
      else:
        raise ValueError("ERROR: vdi checksum incorrect for %s  expected %s  got %s" % (copyLocation, checksumVdi, checksum))
      if copyLocation != self.localVdi:
        cmd = "/bin/cp %s %s" % (copyLocation, self.localVdi)
        self.osSystem(cmd)
    else:
      raise ValueError('ERROR: unknown vdi specification "%s"' % vdi)
    assert os.path.isfile(self.localVdi)
    cmd = 'sh -c "%s 2>&1 | tee log-qemu.txt"' % self.cmd
    print("INFO: starting Qemu  %s" % cmd, flush=True)
    self.logReplay(cmd)
    self.fh = pexpect.spawn(cmd, maxread=200000, searchwindowsize=200000)
    try:
      self.fh.expect("QEMU", timeout=120)
      self.fh.send("\r")
    except:
      pass  # the guest OS is tested separately, no need for return code
    time.sleep(30)  # ssh to the qemu guest is getting random errors, maybe this can help

  def testGuest(self, numAttempts):
    # Make sure the qemu quest is functional
    phaseId = self.restartId
    for attempId in range(numAttempts):
      print("\nINFO: testGuest  phase %d  attempt %d" % (phaseId, attempId), flush=True)
      testFile = "test_qemu_guest-%02d-%02d.txt" % (phaseId, attempId)
      testFileVm = "/tmp/" + testFile
      testFileReturned = testFile.replace(".txt", "-ret.txt")
      with open(testFile, 'w') as f:
        f.write("Test attempt %02d" % attempId)
      self.rsyncToVm(testFile, testFileVm)
      self.rsyncFromVm(testFileVm, testFileReturned)
      if os.path.isfile(testFileReturned):
        print("INFO: testGuest PASSED after attempt %d\n" % attempId, flush=True)
        return True
      print("INFO: testGuest diagnosing ssh connection %d" % attempId, flush=True)
      self.sshCmd("/bin/true", "-vvv")  # Baseline diagnostics
      time.sleep(30)  # on c5 the ssh returns immediately so allow wait beween attempts
    return False
  
  def stop(self):
    self.rsyncFromVm("/var/log/syslog", ".")
    checksum = sha256checksum(self.localVdi)
    
    # Remove vdi to reduce disk space (after printing its checksum for later forensics)
    print("INFO: Qemu.stop: removing vdi file %s %s" % (self.localVdi, checksum), flush=True)
    try:
      os.remove(self.localVdi)
    except OSError:
      pass
        
    # Clean up Qemu process
    try:
      self.fh.expect("Something non-existing to flush logs...", timeout=5)
    except:
      pass    
    print("INFO: stopping QEMU")
    try:
      self.fh.close()
    except:
      pass

    # Store previous attempt qemu logs
    cmd = "tar cvzf logs-qemu-restart-%02d.tgz log-qemu*.txt" % self.restartId
    print("INFO: Qemu.stop:  %s" % cmd)
    self.osSystem(cmd)
    
    # Various reports
    print("INFO: checking for zero-size files:", flush=True)
    self.osSystem("find -size 0")
    
    # Non-git flow - fix permissions on restricted files
    if os.path.exists('syslog'):
      os.chmod('syslog', stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH)

  def checkDoubleEvents(self):  # Return: True is good, False is bad
    cmd = "egrep 'Double .+ of event' log-qemu.txt"
    print("INFO: performing double event check using  %s" % cmd)
    ok = os.WEXITSTATUS(self.osSystem(cmd)) == 1
    print("INFO: double event check %s" % "PASS" if ok else "FAIL")
    return ok
    

class Zebu(BePlat):
  def __init__(self, zebuHost, grpcHost="localhost", grpcPort=defaultGrpcPort):
    BePlat.__init__(self, grpcHost=grpcHost, grpcPort=grpcPort)
    match = re.search(r'(\S+)--(\S+)', zebuHost)
    if match:
      self.zebuHost  = match.groups()[0]
      self.rtlSandbox = match.groups()[1]
    else:
      raise ValueError("ERROR: unparsable zebu host spec %s" % zebuHost)
    self.type = "emu"
    self.sshHost = self.zebuHost.replace("server", "Guest")
    self.sshUser = "synopsys"
    self.tongaDevice = "0000:01:00.0"  # later get from lspci
    sshOpt = "-o StrictHostKeyChecking=no -o ConnectTimeout=600 -o UserKnownHostsFile=/dev/null"
    self.sshCommand = 'ssh -n %s -i %s ' % (sshOpt, self.pemFile)
    self.cmdForRsync = 'rsync -av --progress -e "ssh %s -i %s"' % (sshOpt, self.pemFile)
    #self.cmdForRsync = 'rsync --rsync-path "sudo rsync" -av --progress -e "ssh %s -i %s"' % (sshOpt, self.pemFile)
    self.grpcPort = zebuGrpcHost[self.zebuHost]
    print("INFO: using port %d for grpc  (--grpcPort was %d)" % (self.grpcPort, grpcPort))

  def startTonga(self):
    # Boot Tonga
    tongaOk = False
    logo = "/tmp/log-%s-%s.txt" % (self.zebuHost,self.rtlSandbox)
    cmd = "/rdata/aus11/proj/vbox/bin/rune -ptbto 99999 -nodbg -k all -ptrq -sbdir %s > %s ; " % (self.rtlSandbox, logo)
    sshcmd = 'ssh %s "%s"' % (self.zebuHost, cmd)
    print(sshcmd)
    return os.system(sshcmd) == 0

  def startVm(self):
    # Boot the VM:
    vmOk = False
    assert not portInUse(self.grpcPort)
    cmd = 'sh -c "%s 2>&1 | tee log-zebu_vm.txt"' % ("ssh -L %d:localhost:%d %s" % (self.grpcPort, self.grpcPort, self.zebuHost))
    print("INFO: starting Zebu VM  %s" % cmd, flush=True)
    self.fh1 = pexpect.spawn(cmd, maxread=200000, searchwindowsize=200000)
    self.fh1.expect("$")

    self.fh1.send("source ~/.vbox_bashrc\r")
    self.fh1.expect("$")

    self.fh1.send("cdpt%s\r" % self.rtlSandbox)
    self.fh1.expect("$")

    self.fh1.send("rune -vbrun\r")
    self.fh1.expect("VBoxManage startvm")
    try:
      idx = self.fh1.expect(["has been successfully started",
                           "add any error case here"],
                           timeout=120)
      if idx == 0:
        print("INFO: started Zebu VM")
        vmOk = True
      elif idx == 1:
        print("INFO: add error condition description here")
    except TIMEOUT:
      print("ERROR: Try %d Zebu Tonga VM boot timeout out, please review log-zebu_tonga.txt" % self.restartId)
    
    if vmOk:
      print("INFO: Zebu Vm started OK", flush=True)
    else:
      print("ERROR: Zebu Vm failed to start", flush=True)

    return vmOk
  

  def initGuestOs(self):
    guestOk = False
    self.fh1.send("\r")
    print("Sleeping for a minute before vbssh")
    self.osSystem("sleep 60") 
    runeCmd = "rune -vbqssh %d\r" % (self.grpcPort)
    #self.fh1.send("rune -vbssh\r")
    self.fh1.send(runeCmd)
    try:
      self.fh1.expect("synopsys@localhost's password:", timeout=60)
    except:
      # Debug diagnostics, should not exist is normal use
      print("WARNING: failed to receive guestOS password prompt. Debug manually, sleep 61, kill the sleep process to resume", flush=True)
      self.osSystem("sleep 61")
    self.fh1.send("iltwas\r")
    self.fh1.expect("Last login:")

    self.fh1.send("sudo su\r")
    self.fh1.expect("root@synopsys-VirtualBox:")

    self.fh1.send("mount -t vboxsf SharedFolder /media/sf_SharedFolder/\r")
    self.fh1.expect("root@synopsys-VirtualBox")
    
    # To unify with qemu flow
    self.fh1.send("mkdir -p %s; chown synopsys %s\r" % (krtVmPath, krtVmPath))
    self.fh1.expect("")
    #  does NOT work on the Shared folder, replaed by sudo
    #self.fh1.send("mkdir -p %s; chown synopsys %s\r" % (kelfVmDirGlobal, kelfVmDirGlobal))
    #self.fh1.expect("")

    self.fh1.send("lspci -v\r")
    try:
      idx = self.fh1.expect(["System peripheral: Device 1d0f:7064",
                           "add any error case here"],
                           timeout=60)
      if idx == 0:
        print("INFO: started Zebu guest OS is up and lspi shows tonga", flush=True)
        guestOk = True
    except TIMEOUT:
      print("INFO: Zebu guest OS lspi does NOT have any tonga", flush=True)

    return guestOk

  def start(self, restartId):
    self.restartId = restartId
    if self.startTonga():
      if self.startVm():
        return self.initGuestOs()
    return False
    
    
  def stop(self):
    # Debug window for manual post-mortem
    #print("WARNING: Zebu.stop() sleep 900, kill the sleep process to resume", flush=True)
    #self.osSystem("sleep 900")

    # Clean up Zebu process
    try:
      # FIX_THIS: check with Ravi if there is a "nice quit" capability
      self.fh.send("quit\r")
      self.fh.expect("zebu really quit\r", timeout=5)
    except:
      pass    
    print("INFO: stopping ZEBU TONGA", flush=True)
    try:
      self.fh.close()
    except:
      pass
    
    # Clean up VM
    try:
      # FIX_THIS: check with Ravi if there is a "nice quit" capability
      self.fh1.send("exit\r")
      self.fh1.expect("vm really quit\r", timeout=5)
    except:
      pass    
    print("INFO: stopping ZEBU VM", flush=True)
    try:
      self.fh1.close()
    except:
      pass
    
class PythonTest:
  """Class that is used for running/stopping python test

  """

  def __init__(self, krtd):
    self.pytestFail = False
    self.pytestResultXml = "pytestResult.xml"
    self.krtd = krtd

  def run(self, args):
    krtOk = False
    binDir = self.krtd.tempBinDir
    workDir = self.krtd.tempWorkingDir
    pyExec = 'pytest'
    pyTest = '%s/bin/tests' % (binDir)
    krt_python_path = "%s/bin/" % (binDir)
    os.environ['KRT_PYTHON_PATH'] = krt_python_path
    pytestLogFile = "%s/log-pytest.txt" % (workDir)
    grpcAddress = "%s:%d" % (self.krtd.qemu.grpcHost,self.krtd.qemu.grpcPort)
    machine = "%s" % (self.krtd.qemu.type)
    junit = "--junitxml=%s/%s" % (workDir, self.pytestResultXml)
    with open(pytestLogFile, "a+") as fp:
      p = subprocess.Popen([pyExec, pyTest, "--address", grpcAddress, "--machine", machine, junit, "-s"], stdout=fp, stderr=fp)
      p.communicate()
      if p.returncode == 0:
        krtOk = True
      else:
        self.pytestFail = True
    self.krtd.qemu.rsyncFromVm(self.krtd.kelfVmDir + "/log-krtd.txt", ".")
    cmdCpOutFile = 'cp %s/* %s' % (workDir,self.krtd.cwd)
    self.krtd.qemu.osSystem(cmdCpOutFile)
    if not krtOk:
      print("ERROR: pytest did not run properly check log-pytest.txt")
    else:
      print("INFO: pytest ran fine")

  def parsePytestResultXml(self):
    binDir = self.krtd.tempBinDir
    workingDir = self.krtd.tempWorkingDir
    pyResultFile = "%s/%s" % (workingDir, self.pytestResultXml)
    tree = ET.parse(self.pytestResultXml)
    root = tree.getroot()
    if root.attrib['errors'] != '0' or root.attrib['failures'] != '0':
        return 0
    return 1

  def stop(self): 
    if not self.pytestFail:
      testOk = self.parsePytestResultXml()
    else:
      testOk = False
    if not testOk:
      print("ERROR: pytest did not return zero exit code, check log-krtd.txt, log-pytest.txt, pytestResult.xml")

    return testOk

class KrtcInferResultCache:
  """Class that saves the infer result files sha

  """
  def __init__(self,resultDir):
    self.inferChecksumDict = {}
    for fileName in os.listdir(resultDir):
      fileFullPath = resultDir + "%s" % fileName
      if os.path.isfile(fileFullPath):
        self.inferChecksumDict[fileName] = sha256checksum(fileFullPath)
        print("INFO: Saved checksum for %s:%s\n" % (fileFullPath, self.inferChecksumDict[fileName]))

  def __eq__(self, other):
    if isinstance(other, self.__class__):
      for fileName in self.inferChecksumDict:
        if not fileName in other.inferChecksumDict:
          print("ERROR: filename :%s does not exist in first infer\n" % fileName)
          return False
        if self.inferChecksumDict[fileName] != other.inferChecksumDict[fileName]:
          print("ERROR: inference SHA of output files does not match with first infer\n")
          print("ERROR: checksum for %s:%s\n" % (fileName, other.inferChecksumDict[fileName]))
          return False
        print("INFO: checked checksum for %s:%s\n" % (fileName, other.inferChecksumDict[fileName]))
      return True
    else:
      return False


class KrtcClient:
  """Class that is used for running/stopping krtc client

  """
  def __init__(self, krtd):
    self.loadPassFile = "krtc_load.pass"
    self.loadFailFile = "krtc_load.fail"
    self.krtd = krtd
    self.loadFail = False
    self.inferFail = False

  def krtcLoadStartModel(self, binDir, workingDir):
    krtcCmd = "%s/bin/krtc/krtc" % (binDir)
    loadLogFile = "%s/log-load-start.txt" % (workingDir)
    grpcAddress = "%s:%d" % (self.krtd.qemu.grpcHost,self.krtd.qemu.grpcPort)
    kelfFile = "%s/kelf.tar.gz" % (workingDir)
    model_id = 1001 #TODO need to remove the hard coding
    krtOk = False
    with open(loadLogFile, "a+") as fp:
      p = subprocess.Popen([krtcCmd, "load", kelfFile, "--address", grpcAddress], stdout=fp, stderr=fp)
      p.communicate()
      if p.returncode == 0:
        krtOk = True
      else:
        self.loadFail = True

      p = subprocess.Popen([krtcCmd, "start", "--model-id", str(model_id), "--address", grpcAddress], stdout=fp, stderr=fp)
      p.communicate()
      if p.returncode == 0:
        krtOk = True
      else:
        self.loadFail = True

    self.krtd.qemu.rsyncFromVm(self.krtd.kelfVmDir + "/log-krtd.txt", ".")
    cmdCpOutFile = 'cp %s/* %s' % (workingDir,self.krtd.cwd)
    self.krtd.qemu.osSystem(cmdCpOutFile)
    if not krtOk:
      print("ERROR: model did not load properly check %s" % loadLogFile)
    else:
      print("INFO: model load success")

    return model_id,krtOk

  def krtc_ifmaps(self, ifmapPathList, ifmapFileList):
    if len(ifmapPathList) != len(ifmapFileList):
        return None

    print("INFO:ifmapPathList:%s" % ifmapPathList)
    print("INFO:ifmapFileList:%s" % ifmapFileList)
    if len(ifmapFileList) == 1:
        # currently we are using IN. When that changes, just remove this
        return ifmapPathList

    newifmapPathList = []
    i = 0
    for name in ifmapFileList:
        newifmapPathList.append(name[:-4]) #remove the .npy
        newifmapPathList.append(ifmapPathList[i])
        i = i + 1

    print("INFO:newifmapPathList:%s" % newifmapPathList)

    return newifmapPathList

  def krtcInference(self, model_id, ifmapList, ofmapPath, timeout, binDir, workingDir, capture):
    krtOk = False
    binDir = self.krtd.tempBinDir
    workDir = self.krtd.tempWorkingDir
    (ifmapPathList,ifmapFileList) = self.krtd.getIfMapFile(ifmapList, ofmapPath)
    krtcCmd = "%s/bin/krtc/krtc" % (binDir)
    inferLogFile = "%s/log-infer.txt" % (workingDir)
    modelId = "%s" % model_id
    grpcAddress = "localhost:%d" % self.krtd.qemu.grpcPort

    ifmaps = self.krtc_ifmaps(ifmapPathList, ifmapFileList)
    with open(inferLogFile, "a+") as fp:
      krtcArgs = [krtcCmd, "infer", "--model-id", modelId, "--ifmap"] +  ifmaps + ["--ofmap-path", ofmapPath, "--address", grpcAddress, "--timeout", timeout]
      if capture:
        krtcArgs += ["--capture"]
      p = subprocess.Popen(krtcArgs, stdout=fp, stderr=fp)
      p.communicate()
      if p.returncode == 0:
        krtOk = True
      else:
        self.inferFail = True
    self.krtd.qemu.rsyncFromVm(self.krtd.kelfVmDir + "/log-krtd.txt", ".")

    # copies the log files
    cmdCpOutFile = 'cp %s/* %s' % (workingDir,self.krtd.cwd)
    self.krtd.qemu.osSystem(cmdCpOutFile)

    #copies the output files
    cmdCpOutFile = 'cp %s* %s' % (ofmapPath,self.krtd.cwd)
    self.krtd.qemu.osSystem(cmdCpOutFile)


    if not krtOk:
      print("ERROR: infer failure for ifmap:%s check log-infer.txt" % ifmaps)
    else:
      print("INFO: infer success for ifmap:%s" % ifmaps)
    return krtOk

  def doMultipleKrtcInference(self, model_id, ifmapList, timeout, binDir, workingDir):
    krtOk = True
    ofmapDirList = []
    for inferenceNum in range(numInferences):
      print("INFO: Doing Inference Number:%d\n" % inferenceNum)
      ofmapDirList.append(self.krtd.createTempDir(workingDir + "/infer_%s/" % inferenceNum))
      #once krtc to send capture o/p to different dir we might not need this and capture
      #always. Right now the first time we don't capture in multi inference case
      capture = (numInferences == 1) or (inferenceNum >=1)
      krtOk = self.krtcInference(model_id, ifmapList, ofmapDirList[inferenceNum], timeout, binDir, workingDir, capture)
      if not krtOk:
        print("ERROR: inference %d failed\n" % inferenceNum)
        break
      if numInferences == 1:
        break

      # If we have more than one inference to run, then cache the result
      # of first that will be used for subsequent to be compared with
      if inferenceNum == 0:
        firstInferClass = KrtcInferResultCache(ofmapDirList[inferenceNum])
      else:
        krtOk = (firstInferClass == KrtcInferResultCache(ofmapDirList[inferenceNum]))
        if not krtOk:
          self.inferFail = True
          break

    for dir in ofmapDirList:
      self.krtd.removeTempDir(dir)

    return krtOk

  def addModel(self, kelfDir, workingDir):
    cmdCpy = 'cd %s; cp kelf.tar.gz %s/.' % (kelfDir, workingDir)
    self.krtd.qemu.osSystem(cmdCpy)

  def run(self, args):
    binDir = self.krtd.tempBinDir
    workingDir = self.krtd.tempWorkingDir
    self.addModel(args.kelf, workingDir)
    (model_id, krtOk) = self.krtcLoadStartModel(binDir, workingDir)  #in future this would take the tpb in which to load
    if not krtOk:
      return
    krtOk = self.doMultipleKrtcInference(model_id, args.ifmaps, str(self.krtd.inklingTimeout),binDir, workingDir)
    if not krtOk:
      return
    self.krtd.getFinalBin()

  def stop(self):
    if self.loadFail or self.inferFail:
      return False
    return True

class Krtd():
  """Class that is used for starting/stopping krtd daemon
	"""
  def __init__(self, qemu, timeout):
    self.qemu = qemu
    self.cwd = os.getcwd()
    self.inklingTimeout = timeout
    self.kelfVmDir = kelfVmDirGlobal  # non-sg spefic, for --action cleanup_pool
    self.sg = "sg00"
    # env needed for the installed krt
    p = krtVmPath
    epath = os.getenv('PATH')
    eldlp = os.getenv('LD_LIBRARY_PATH')
    self.envStr = '  PATH=%s:%s:%s' % (p, p + '/bin', epath)
    self.envStr += '  LD_LIBRARY_PATH=%s:%s:%s ' % ( p, p + "/lib", eldlp)
    self.krtdPass = "krtd.pass"
    self.krtdFail = "krtd.fail"
    self.tempBinDir = ''
    self.tempWorkingDir = ''

  def install(self):
    runtimSrcPath = os.environ["KAENA_RT_PATH"]
    if not os.path.isdir(runtimSrcPath):
      raise ValueError("ERROR: missing runtime src at %s" % runtimSrcPath)
    krtPkgPattern = 'krt-*.*-*-core.tar.gz'
    krtPackages = glob.glob(os.path.join(krtBldPath, krtPkgPattern))
    if len(krtPackages) != 1:
      raise ValueError("ERROR: Found {} runtime packages at {}".format(len(krtPackages), krtBldPath))
    self.qemu.sshCmd("/bin/rm -rf %s/*" % krtVmPath )
    self.qemu.rsyncToVm(krtPackages[0], krtVmPath + "/")
    #self.qemu.rsyncToVm(os.path.join(runtimSrcPath, "kbinlib", "vfio_bind.py"), krtVmPath + "/")
    self.qemu.sshCmd("sudo sysctl -w vm.nr_hugepages=128")
    self.qemu.sshCmd("cd %s &&  sudo tar xvfz %s" % (krtVmPath, krtPkgPattern))
    #self.qemu.sshCmd("cd %s &&  sudo modprobe vfio enable_unsafe_noiommu_mode=Y" % krtVmPath)
    self.qemu.sshCmd("sudo python3 %s/vfio_bind.py" % (krtVmPath + '/bin'))

  def scrub_dram(self):
    tongaDev = self.qemu.getTongaDevice()
    cmd = "sudo %s/krtd -t %s & \
           sleep 10 && \
           cd %s && \
           python3 kdb.py 'attach' 'expert scrub' quit && \
           sleep 1 && \
           sudo pkill krtd" % (krtVmPath + '/bin', tongaDev, krtVmPath + '/bin/kdb')

    self.qemu.sshCmd(cmd)

  # block level reset for tpb/dma engines. 
  def force_reset_blocks(self):
    tongaDev = self.qemu.getTongaDevice()
    cmd = "sudo %s/krtd -t %s & \
           sleep 10 && \
           cd %s && \
           python3 kdb.py 'attach' 'expert reset_block --tpb --dma' quit && \
           sleep 1 \
           && sudo pkill krtd" % (krtVmPath + '/bin', tongaDev,krtVmPath + '/bin/kdb')

    self.qemu.sshCmd(cmd)

   
  def getFinalBin(self):
    ##topFinalDir = self.kelfVmDir + "/"
    topFinalDir = "/tmp/"
    finalBinfiles = ""
    for fin in ["pe", "act", "pool"]:
      finalBinfiles += topFinalDir + fin + "-final.bin "
    self.qemu.rsyncFromVm(finalBinfiles, ".")

  def getIfMapFile(self, ifmapList, ofmap):
    self.ofmap = ofmap
    ifmapPathList = []
    ifmapFileList = []
    for ifmap in ifmapList:
      ifmapFile = ifmap
      ifmapPath = os.path.realpath(ifmap)
      print("INFO ifmapFile:%s" % ifmapFile)
      print("INFO ifmapPath:%s" % ifmapPath)
      # kaena-602: hack for testing one input file only; doesn't work for inferencing
      ifmapPadSplitPath = ifmapPath[:-4] + "_padsplit.npy" 
      ifmapPadFile = ifmapFile[:-4] + "_padsplit.npy"
      if os.path.isfile(ifmapPadSplitPath):
        print("qemu_rt: Replacing original npy input ", ifmapPath, " with padded input ", ifmapPadSplitPath)
        ifmapPath = ifmapPadSplitPath
        ifmapFile = ifmapPadFile
      else:
        print("qemu_rt: Using original npy input ", ifmapPath, " did not find padded input ", ifmapPadSplitPath)
      ifmapPathList.append(ifmapPath)
      ifmapFileList.append(ifmapFile)

    return ifmapPathList, ifmapFileList

  def startDaemon(self):
    # The following will go away once we start supporting switch model
    # wait for few seconds after krtd is killed
    self.qemu.sshCmd("sudo killall krtd")
    time.sleep(5) # wait for few seconds after killing krtd before starting
    self.qemu.sshCmd("mkdir -p %s" % kelfVmDirGlobal)
    self.qemu.sshCmd("/bin/rm -rf %s/*" % kelfVmDirGlobal)
    tongaDev = self.qemu.getTongaDevice()
    krtd = '%s/bin/krtd' % krtVmPath
    config = '%s/bin/default_config.json' % krtVmPath
    grpc = '0.0.0.0:%d' % self.qemu.grpcPort
    cmdKrtd = '%s -t %s -c %s -g %s' % (
               krtd,tongaDev,config, grpc)

    shCmd="cd %s && %s ldd %s && if %s %s; then touch %s; else touch %s; fi" % (
        self.kelfVmDir, self.envStr, krtd, self.envStr, cmdKrtd, self.krtdPass, self.krtdFail)
    cmdRuntime = 'sudo /bin/sh -c "(%s) > %s/log-krtd.txt 2>&1 & "' %  (
        shCmd, self.kelfVmDir)

    self.qemu.sshCmd(cmdRuntime)

    # Now wait for the krtd to be ready
    filesToWaitForStr = "%s/%s %s/log-krtd.txt" % (self.kelfVmDir, self.krtdFail, self.kelfVmDir)
    for i in range(self.inklingTimeout):
      print("  Waiting for krtd to start %i" %i, flush=True)
      time.sleep(1)
      self.qemu.rsyncFromVm(filesToWaitForStr, ".")
      if os.path.isfile("log-krtd.txt"):
        f = open("log-krtd.txt", "rb")
        filetext = f.read().decode('utf-8')
        f.close()
        found = re.search("Server listening", filetext)
        if (found != None):
          return True
      if os.path.isfile(self.krtdFail):
        break
    print("ERROR: krtd did not start properly check log-krtd.txt")
    return False

  def createTempDir(self, name):
    if os.path.exists(name):
     shutil.rmtree(name)
    os.makedirs(name)
    print("INFO %s : Created tmp file %s" % (str(datetime.datetime.now()),name), flush=True)
    return(name)

  def removeTempDir(self, name):
    shutil.rmtree(name)

  def localInstall(self):
    '''
    If any install procedure changes, make sure to update the remote install also
    '''
    runtimSrcPath = os.environ["KAENA_RT_PATH"]
    if not os.path.isdir(runtimSrcPath):
      raise ValueError("ERROR: missing runtime src at %s" % runtimSrcPath)
    krtPkgPattern = 'krt-*.*-*-core.tar.gz'
    krtPackages = glob.glob(os.path.join(krtBldPath, krtPkgPattern))

    if len(krtPackages) != 1:
      raise ValueError("ERROR: Found {} runtime packages at {}".format(len(krtPackages), krtBldPath))
    self.tempBinDir = self.createTempDir(os.getcwd() + "/krtdBin")
    if not os.path.isdir(self.tempBinDir):
      raise ValueError("ERROR: Could not create tmp dir for local binary")
    self.qemu.osSystem("cd %s &&  tar xvfz %s/%s" % (self.tempBinDir, krtBldPath,krtPkgPattern))
    self.tempWorkingDir = self.createTempDir(os.getcwd() + "/krtdWork")
    if not os.path.isdir(self.tempWorkingDir):
      raise ValueError("ERROR: Could not create tmp dir for local work")
    self.qemu.osSystem("cd %s &&  rm -rf bin/__pycache__" % (self.tempBinDir))
    self.qemu.osSystem("cd %s &&  rm -rf bin/tests/__pycache__" % (self.tempBinDir))

  def cleanup(self):
    binDir = self.tempBinDir
    workingDir = self.tempWorkingDir
    if os.path.exists(binDir): self.removeTempDir(binDir)
    if os.path.exists(workingDir): self.removeTempDir(workingDir)

  def execute(self, args):
    krtOk = self.startDaemon()
    if not krtOk:
      return krtOk
    if (args.pytest):
      self.client = PythonTest(self)
    else:
      self.client = KrtcClient(self)
      
    self.localInstall()
    self.client.run(args)
    krtOk = self.client.stop()
    self.cleanup()
    return krtOk

  def __del__(self):
    self.cleanup()

class QemuPool:
  def __init__(self, ports, vdi, mem, inklingTimeout):
    if len(ports) == 2:
      self.ports = range(ports[0], ports[1])
    else:
      self.ports = ports
    self.qemus = []
    for port in self.ports:
      qemu = Qemu(vdi, mem, port)
      krt = Krtd(qemu, inklingTimeout)
      self.qemus.append((qemu, krt))
  def checkPorts(self):
    for port in self.ports:
      if portInUse(port):
        return False
    return True
  def startPool(self):
    if self.checkPorts():
      for idx in range(len(self.ports)):
        port = self.ports[idx]
        qemu, krt = self.qemus[idx]
        d = "pool_%d" % port
        os.mkdir(d)
        os.chdir(d)
        for qemuRestartId in range(3):
          qemu.start(qemuRestartId)
          if qemu.testGuest(4):
            krt.install()
            break
          else:
            qemu.stop()
        os.chdir("..")
    else:
      raise ValueError("ERROR: cannot start qemu pool - the ports are in use")
    return len(self.qemus) == len(self.ports)
  def getAvailQemu(self):
    found = False
    while not found:
      idx = random.randint(0, len(self.qemus)-1)
      print("INFO: trying to lock QEMU %d on port %d ..." % (idx, self.ports[idx]), flush=True)
      qemu, krt = self.qemus[idx]
      found = qemu.lock()
      time.sleep(1)
    print("INFO: locked QEMU %d on port %d" % (idx, self.ports[idx]), flush=True)
    return qemu, krt
  def cleanup(self):
    for idx in range(len(self.ports)):
      port = self.ports[idx]
      qemu, krt = self.qemus[idx]
      qemu.unlock()

class ZebuPool:
  def __init__(self, zebuHosts, inklingTimeout):
    self.zebuHosts = zebuHosts
    self.zebus = []
    for host in self.zebuHosts:
      zebu = Zebu(host)
      krt = Krtd(zebu, inklingTimeout)
      self.zebus.append((host, zebu, krt))
  def startPool(self):
    for host, zebu, krt in self.zebus:
      d = "pool_%s" % host
      os.mkdir(d)
      os.chdir(d)
      for qemuRestartId in range(2):
        if zebu.start(qemuRestartId):
          krt.install()
          #krt.scrub_dram()
          break
        else:
          zebu.stop()
      os.chdir("..")
    return len(self.zebus) == len(self.zebuHosts)
  def getAvailZebu(self):
    found = False
    while not found:
      idx = random.randint(0, len(self.zebus)-1)
      host, zebu, krt = self.zebus[idx]
      print("INFO: trying to lock Zebu on host %s ..." % (host), flush=True)
      found = zebu.lock()
      time.sleep(1)
    print("INFO: locked ZEBU on host %s" % (host), flush=True)
    return zebu, krt
  def cleanup(self):
    for idx in range(len(self.zebus)):
      host, zebu, krt = self.zebus[idx]
      zebu.unlock()

#########################################################

inklingTimeout = 6000
# Override krt_bin inference timeout - this is used e.g.
#   by the DV team to only collect final bin files
envQemuKrtTimeout = os.getenv("QEMU_KRT_TIMEOUT", None)
if envQemuKrtTimeout != None:
  inklingTimeout = int(envQemuKrtTimeout)
os.nice(19)

##############  zebu pool  ##############
if args.zebu != None and args.zebu.startswith('pool'):
  zebuPoolStr = args.zebu.replace('pool', '')
  qp = ZebuPool(zebuPoolStr.split(), inklingTimeout)
  if args.action == 'start_pool':
    if not qp.startPool():
      raise RuntimeError('ERROR: failed to start zebus, %d requested while %d started' % (len(qp.zebuHosts), len(qp.zebus)))
    print('INFO: your zebu pool has started. You can access it on hosts %s. To stop them terminate this process' % qp.zebuHosts, flush=True)
    i = 0
    #Now save the pid of this process so that when we
    #need to kill the pool we can use that. The file
    #saved in the dir from which pool start command was
    #issued. So cleanpool should also be called from
    #the same place
    pid = os.getpid()
    if os.path.isfile(poolPidFileName):
      os.remove(poolPidFileName)
    with open(poolPidFileName, 'w') as fp:
      fp.write(str(os.getpid()))

    while True:
      time.sleep(10)
      print('\nINFO: holding zebus iteration %d. Sleep 10. Use  export KAENA_ZEBU_SERVER="pool %s"; RunAll --force_qemu --parallel %d --test ... to run.   Terminate this process to close the zebus' % (
             i, " ".join(str(p) for p in qp.zebuHosts), len(qp.zebus)), flush=True)
      i += 1
      # Zebu heartbeet
      for  host, zebu, krt in qp.zebus:
        zebu.sshCmd('echo -n "  Zebu pool heartbeat on %s ";  TZ=America/Los_Angeles uptime' % host)
  elif args.action == 'cleanup_pool':
    qp.cleanup()
    if os.path.isfile(poolPidFileName):
      with open(poolPidFileName, 'r') as fp:
        os.kill(int(fp.read()), signal.SIGKILL)
        os.remove(poolPidFileName)
    sys.exit(0)

  elif args.action == 'inference':
    # since the default action is inference and for pytest we don't
    # set any action, we land up here. Don't check for kelf in
    # that case
    if args.kelf == None and not args.pytest:
      raise ValueError("ERROR: use --kelf")
    zebu, krt = qp.getAvailZebu()
    krtOk = krt.execute(args)
    #krt.force_reset_blocks()
    zebu.unlock()
    sys.exit(0 if krtOk else 1)
  raise RuntimeError("ERROR: zebu pool is not yet supported")

##############  zebu  ##############
elif args.zebu != None:
  zebuOk = False
  krtOk = False
  for zebuRestartId in range(2):
    zebu = Zebu(args.zebu,grpcHost=args.grpcHost, grpcPort=args.grpcPort)
    if zebu.start(zebuRestartId):
      zebuOk = True
      krt = Krtd(zebu, inklingTimeout)
      krt.install()
      #krt.scrub_dram()
      krtOk = krt.execute(args)
    else:
      print("ERROR: Failed to start Zebu  phase %d, restarting ..." % zebuRestartId)
    zebu.stop()
    if zebuOk:
      break
  if zebuOk:
    sys.exit(0 if krtOk else 1)
  raise ValueError("ERROR: Failed to start ZEBU")

##############  qemu pool  ##############
elif len(args.pool) > 0:
  qp = QemuPool(args.pool, args.vdi, args.mem, inklingTimeout)
  if args.action == 'start_pool':
    if not qp.startPool():
      raise RuntimeError('ERROR: failed to start qemus, %d requested while %d started' % (len(qp.ports), len(qp.qemus)))
    print('INFO: your qemu pool has started. You can access it on ports %s. To stop them terminate this process' % qp.ports, flush=True)
    i = 0
    while True:
      time.sleep(10)
      print('INFO: holding quemus %d. Sleep 10. Use  export KAENA_QEMU_RT_POOL="%s"; RunAll --force_qemu --test ... to run.   Terminate this process to close the qemus' % (i, " ".join(str(p) for p in qp.ports)), flush=True)
      i += 1
  elif args.action == 'cleanup_pool':
    qp.cleanup()
  elif args.action == 'inference':
    # since the default action is inference and for pytest we don't
    # set any action, we land up here. Don't check for kelf in
    # that case
    if args.kelf == None and not args.pytest:
      raise ValueError("ERROR: use --kelf")
    qemu, krt = qp.getAvailQemu()
    krtOk = krt.execute(args)
    qemu.unlock()
    sys.exit(0 if krtOk else 1)
    
##############  single qemu  ##############
else:
  # port mode
  if args.kelf == None and not args.pytest:
    raise ValueError("ERROR: use --kelf")
  qemuOk = False
  krtOk = False
  port = args.port
  grpcHost = args.grpcHost
  grpcPort = args.grpcPort
  for qemuRestartId in range(3):
    qemu = Qemu(args.vdi, args.mem, port, grpcHost=grpcHost, grpcPort=grpcPort)
    qemu.start(qemuRestartId)
    if qemu.testGuest(4):
      qemuOk = True
      krt = Krtd(qemu, inklingTimeout)
      krt.install()
      krtOk = krt.execute(args)
    else:
      print("ERROR: Failed to start Qemu  phase %d, restarting ..." % qemuRestartId)
    qemu.stop()
    if not qemu.checkDoubleEvents():
      raise ValueError("ERROR: double event check failed")
    if qemuOk:
      break
    else:
      time.sleep(30)  # qemu was still failing upon several restarts. Delay after stop() may help.
  if qemuOk:
    sys.exit(0 if krtOk else 1)
  raise ValueError("ERROR: Failed to start QEMU")
